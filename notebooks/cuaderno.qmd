---
title: "cuaderno"
format: html
editor: visual
---

Vamos a utilizar el dataset de semillas que se encuentra aquí: https://archive.ics.uci.edu/ml/datasets/seeds#

Primero vamos a descargarnos el dataset con el siguiente comando:

```{r}
library(tidyverse)

# Leer el archivo CSV
airbnb_data <- read.csv("../data/raw/air-bnb-listings.csv", sep = ';')

```

```{r}
# Ver las primeras filas de los datos
head(airbnb_data)

```

```{r}
# Resumen estadístico y estructura del DataFrame
summary(airbnb_data)
```

```{r}
dimension_original <- dim(airbnb_data)

paste('El numero de filas que tiene el dataframe airbnb_data es:', dimension_original[1])
paste('El numero de columnas que tiene el dataframe airbnb_data es:', dimension_original[2])
```

```{r}
colnames(airbnb_data)
```

Para saber con que tipo de datos estoy trabajando:

```{r}

# Crear un vector con los nombres de las columnas
column_names <- colnames(airbnb_data)

# Obtener la clase y el tipo de cada columna utilizando sapply
column_classes <- sapply(airbnb_data, class)
column_types <- sapply(airbnb_data, typeof)

# Crear el dataframe con la información recopilada de Type y Clase 
clase_tipo <- data.frame(
  Class = column_classes,      # Clase de cada columna
  Type = column_types          # Tipo de cada columna
)

# Ver los resultados
print(clase_tipo)


```

```{r}
# Convertir la columna Date.last.review a tipo fecha
airbnb_data$Date.last.review <- as.Date(airbnb_data$Date.last.review, format = "%Y-%m-%d")

# Convertir la columna Updated.Date a tipo fecha
airbnb_data$Updated.Date <- as.Date(airbnb_data$Updated.Date, format = "%Y-%m-%d")

# Convertir columnas seleccionadas a factores (categóricas)
airbnb_data$Room.type <- as.factor(airbnb_data$Room.type)
airbnb_data$Neighbourhood <- as.factor(airbnb_data$Neighbourhood)
airbnb_data$City <- as.factor(airbnb_data$City)
airbnb_data$Country <- as.factor(airbnb_data$Country)
```

```{r}
# Crear un vector con los nombres de las columnas
column_names <- colnames(airbnb_data)

# Obtener la clase y el tipo de cada columna utilizando sapply
column_classes <- sapply(airbnb_data, class)
column_types <- sapply(airbnb_data, typeof)

# Crear el dataframe con la información recopilada de Type y Clase 
clase_tipo <- data.frame(
  Class = column_classes,      # Clase de cada columna
  Type = column_types          # Tipo de cada columna
)

# Ver los resultados
print(clase_tipo)

```

```{r}
# Resumen estadístico y estructura del DataFrame
summary(airbnb_data)
```

```{r}
# Resumen estadístico y estructura del DataFrame
str(airbnb_data)
```

Voy a convertir Availibility en una variable catégorica. Availibility no tiene valores nulos.

```{r}


# Rangos de disponibilidad y sus etiquetas
breaks <- c(-1, 0, 30, 60, 90, 180, 365)
labels <- c("No disponible", "Menos de 30 días", "31 a 60 días", "61 a 90 días", "91 a 180 días", "181 a 365 días")

# Categorizar 'Availability' usando cut()
airbnb_data$Availability_Cat <- cut(airbnb_data$Availibility, breaks = breaks, labels = labels, include.lowest = TRUE)


airbnb_data$Availability_Cat<- as.factor(airbnb_data$Availability_Cat)

summary(airbnb_data$Availability_Cat)


nueva_dimension<-dim(airbnb_data)

paste("El dataset original tenía:", dimension_original[2], "variables. Tras agregar una nueva variable (Availability_Cat) para categorizar Availibility tenemos:",nueva_dimension[2], "variables")


```

```{r}
# Función para determinar el tipo de dato de cada columna
column_type <- function(x) {
  if (is.factor(x)) {
    "Categórica"
  } else if (is.numeric(x)) {
    "Numérica"
  } else if (inherits(x, "Date")) {
    "Fecha"
  } else {
    class(x)[1]  # Devuelve la primera clase si es un tipo compuesto o simplemente la clase si no es de los tipos anteriores
  }
}

# Aplicar la función a cada columna y crear un dataframe de resultados
resultados <- data.frame(
  Type = sapply(airbnb_data, column_type)   # Tipo determinado por la función
)

# Mostrar los resultados
print(resultados)



```

```{r}
# Aplicar la función a cada columna para obtener los tipos
types <- sapply(airbnb_data, column_type)

# Crear un dataframe de resumen con los recuentos de cada tipo
type_counts <- table(types)

# Convertir la tabla en un dataframe para una mejor visualización
type_summary <- as.data.frame(type_counts)

# Renombrar las columnas del dataframe
names(type_summary) <- c("Type", "Count")

# Mostrar el resumen
print(type_summary)

```

```{r}
# Obtener un resumen de las columnas numéricas
summary(airbnb_data[sapply(airbnb_data, is.numeric)])
```

Quitar todas las filas, cuya ciudad no sea Madrid

```{r}
library(dplyr)


ciudad <- as.data.frame(table(airbnb_data$City)) 

print(ciudad)

# Filtrar el dataset para mantener solo las filas donde la ciudad es Madrid
airbnb_data <- airbnb_data %>% filter(City == "Madrid")

# Verificar que sólo quedan entradas de Madrid en el dataset original
ciudad <- as.data.frame(table(airbnb_data$City)) 
print(ciudad)

# Verificar las dimensiones del dataset actualizado
dimension_solo_madrid <- dim(airbnb_data)

paste("El dataset original tenía:", dimension_original[1], "observaciones. Tras eliminar los registros que no eran de Madrid, el numero de observaciones es de:",dimension_solo_madrid[1], ". Se han eliminadas:", dimension_original[1] - dimension_solo_madrid[1], "registros" )


```

```{r}
# Asegurándonos de que la columna Coordinates está en formato de string
airbnb_data$Coordinates <- as.character(airbnb_data$Coordinates)

# Separar la columna Coordinates en dos nuevas columnas: Latitude y Longitude
airbnb_data<- airbnb_data %>%
  separate(Coordinates, into = c("Latitude", "Longitude"), sep = ",", convert = TRUE)

paste("La columna Coordinates se ha dividido en 2 :'Latitude', 'Longitude'")

if (!require(tibble)) {
    install.packages("tibble")
}
library(tibble)

# Crear un tibble con los tipos y clases de las columnas Latitud y Longitud
column_info <- tibble(
    Column = c("Latitude", "Longitude"),
    Type_of_Data = c(typeof(airbnb_data$Latitude), typeof(airbnb_data$Longitude)),
    Class_of_Data = c(class(airbnb_data$Latitude), class(airbnb_data$Longitude))
)

# Mostrar el tibble
print(column_info)


```

¿Puedo borrar Location?

```{r}

library(dplyr)

#Crear una nueva columna temporal que combine Country,City y Neighbourhood para ver si coincide exactamente con la columna Location.

airbnb_data <- airbnb_data |> mutate(Combined = paste(Country, City, Neighbourhood, sep = ", "))

#Comparar la columna Location con la columna Combined para verificar si son iguales.

airbnb_data <- airbnb_data |> mutate(Location_Match = Location == Combined)


#Revisa cuántos y qué porcentaje de las filas tienen coincidencia exacta entre Location y la columna combinada.

table(airbnb_data$Location_Match)

paste("Si concatenamos Country,City y Neighbourhood nos da el mismo resultado que la columna Location, por lo que podemos eliminarla")




```

```{r}
#Eliminar Location por redundante
airbnb_data <- select(airbnb_data, -Location)

#Eliminar columnas temporales Combined y Location_Match
airbnb_data <- select(airbnb_data, -Combined)
airbnb_data <- select(airbnb_data, -Location_Match)
```

Se comparó la columna Location con la combinación de Country, City, y Neighbourhood, y se concluyó que era redundante por lo que se procedió a su eliminación.

```{r}

# Calcular el número de días desde la última revisión hasta la fecha de extracción
date_scraped <- as.Date("2020-07-17")
airbnb_data$time_since_last_review <- as.numeric(difftime(date_scraped, airbnb_data$Date.last.review, units = "days"))

# Histograma del tiempo transcurrido desde la última reseña
ggplot(airbnb_data, aes(x = time_since_last_review)) +
  geom_histogram(bins = 30, fill = "#69b3a2", color = "#e9ecef") + # Colores personalizados para las barras
  theme_minimal() +
  theme(
    text = element_text(family = "Helvetica", size = 12), # Cambia la fuente y el tamaño del texto
    plot.title = element_text(face = "bold", hjust = 0.5), # Negrita y centrado para el título
    plot.subtitle = element_text(face = "italic", hjust = 0.5), # Subtítulo en cursiva y centrado
    axis.title = element_text(face = "bold", size = 13) # Títulos de los ejes en negrita y tamaño aumentado
  ) +
  labs(
    title = "Distribución de días desde la última reseña",
    subtitle = "Visualización de la frecuencia de días transcurridos",
    x = "Días desde la última reseña", y = "Frecuencia"
  )

```

```{r}
airbnb_data <- select(airbnb_data, -Time_category)

```

```{r}
library(dplyr)

airbnb_data <- airbnb_data %>%
  mutate(
    Time_category = factor(
      if_else(
        is.na(time_since_last_review),
        'sin reseñas',  # Asignar directamente 'sin reseñas' si el valor es NA
        cut(  # Usar cut solo en valores no-NA
          time_since_last_review,
          breaks = c(0, 14, 60, 182, 365, Inf),  # Definiendo los rangos
          labels = c('0-2 semanas', '2-8 semanas', '2-6 meses', '6-12 meses', '1+ año'),
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', '0-2 semanas', '2-8 semanas', '2-6 meses', '6-12 meses', '1+ año')
    )
  )



summary(airbnb_data$Time_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-2 semanas, incluye los valores desde 0 a 14 (incluido)
#El intervalo 2-8 semanas, incluye los valores desde 15 a 60 (incluido)  y asi sucesivamente 

```

## Estudio de los valores nulos y ceros.

Creamos un dataframe con los resultados de la contabilizacion por columnas, de nulos y ceros.

```{r}
# Dataframe con la contabilizacion de Nulos y Ceros
resultados <- data.frame(
  NA_Count = colSums(is.na(airbnb_data)),
  Zero_Count = colSums(airbnb_data == 0, na.rm = TRUE)
)

resultados
```

Vemos que existe la misma cantidad de ceros en `Number.of.reviews`, que nulos en `Date.last.review` y `Number.of.reviews.per.month.`

¿Están relacionados estos tres valores?

```{r}

# Añadir una columna temporal para verificar la condición
airbnb_data <- airbnb_data |>
  mutate(
    check = Number.of.reviews == 0 & is.na(Date.last.review) & is.na(Number.of.reviews.per.month)
  )

# Sumar para comprobar la condición basada en Number.of.reviews
result <- airbnb_data %>%
  filter(Number.of.reviews == 0) %>%
  summarise(
    Total_Zero_Reviews = n(),
    Correct_Cases = sum(check)
  )

print(result)



```

Hemos añadido una columna llamada 'check' a nuestro conjunto de datos. Esta columna nos ayuda a ver si el número de reseñas es cero y, al mismo tiempo, si las fechas de la última reseña y el promedio de reseñas por mes están vacíos. Si se cumplen estas condiciones, la columna indica 'verdadero'; si no, muestra 'falso'.

Comparamos la cuenta de los registros donde el número de reseñas es cero, con el número de cuántos de registros que no solo están sin reseñas, sino que también carecen de fecha de última reseña y de promedio de reseñas por mes. Este paso nos permite comprobar si nuestra teoría sobre la relación entre estas variables se sostiene. Tiene sentido, ya que si un alojamiento no ha recibido reseñas, no podría tener una fecha de última reseña ni un promedio de reseñas mensuales.

Una vez probados esto, para poder hacer un mejor tratamiento de datos, vamos a colocar en los valores nulos de `Number.of.reviews.per.month.`ceros.

```{r}
# Sustituir directamente los NA por 0 en la columna específica
airbnb_data$Number.of.reviews.per.month[is.na(airbnb_data$Number.of.reviews.per.month)] <- 0
```

Ahora voy a categorizar esta variable para un mejor análisis

```{r}
library(dplyr)

# Asumiendo que airbnb_data ya está cargado.

airbnb_data <- airbnb_data %>%
  mutate(
    Review_category = factor(
      if_else(
        is.na(Number.of.reviews.per.month) | Number.of.reviews.per.month == 0,  # Condición para NA o cero
        'sin reseñas',  # Valor si la condición es verdadera
        cut(  # Función cut para categorizar los valores no NA y no cero
          Number.of.reviews.per.month,
          breaks = c(0, 1, 5, 10, 20, Inf),  # Puntos de corte para las categorías
          labels = c('0-1/mes', '1-5/mes', '5-10/mes', '10-20/mes', '20+ mes'),  # Etiquetas para cada rango
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', '0-1/mes', '1-5/mes', '5-10/mes', '10-20/mes', '20+ mes')  # Definiendo el orden de los niveles del factor
    )
  )


summary(airbnb_data$Review_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-1/mes, incluye los valores desde 0.01 a 1 (incluido)
#El intervalo 1-5/mes, incluye los valores desde 1,01 a 5 (incluido) y asi sucesivamente 
```


Haremos lo mismo con `Number.of.reviews`

```{r}
library(dplyr)

airbnb_data <- airbnb_data %>%
  mutate(
    Review_Count_Category = factor(
      if_else(
        Number.of.reviews == 0,  # Condición para verificar si hay 0 reseñas
        'sin reseñas',  # Etiqueta para 0 reseñas
        cut(  # Usar cut para valores mayores a 0
          Number.of.reviews,
          breaks = c(0, 1, 10, 50, 100, 500, Inf),  # Ajuste de los rangos para incluir 1 correctamente
          labels = c('1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas'),
          include.lowest = TRUE,
          right = TRUE  # Cambio a TRUE para incluir el valor 1 en la categoría '1 reseña'
        )
      ),
      levels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas')  # Definición explícita del orden de los niveles
    )
  )

# Puedes verificar el resultado con:
summary(airbnb_data$Review_Count_Category)


#NOTA: 
#El intervalo sin reseñas, incluye todos los ceros
#El intervalo1 reseña, incluye solos los valor 1 
#El intervalo '2-10 reseñas', incluye los valores desde 2 a 10 (incluido)
#El intervalo '11-50 reseñas', incluye los valores desde 11 a 50 (incluido) y asi sucesivamente 


```
```{r}

if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "Review_Count_Category.xlsx")



```

```{r}

getwd()

```
```{r}
# Borrar columna temporal check

airbnb_data <- select(airbnb_data, -check)
```

Por otro lado los ceros de **`Availibility`**, se han tratado en la columna **`Availibility_cat`** como alojamientos "No disponibles"

```{r}
# Cargar la librería necesaria
library(ggplot2)

# Boxplot para Room.Price
ggplot(airbnb_data, aes(y = Room.Price)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = "Distribución del Precio de la Habitación",
       y = "Precio (€)",
       x = "") +
  theme_minimal()

# Boxplot para Minimum.nights
ggplot(airbnb_data, aes(y = Minimum.nights)) +
  geom_boxplot(fill = "lightgreen", color = "darkgreen") +
  labs(title = "Distribución del Número Mínimo de Noches Requeridas",
       y = "Número Mínimo de Noches",
       x = "") +
  theme_minimal()

# Boxplot para Number.of.reviews
ggplot(airbnb_data, aes(y = Number.of.reviews)) +
  geom_boxplot(fill = "lightcoral", color = "darkred") +
  labs(title = "Distribución del Número de Reseñas",
       y = "Número de Reseñas",
       x = "") +
  theme_minimal()

# Boxplot para Number.of.reviews.per.month
ggplot(airbnb_data, aes(y = Number.of.reviews.per.month)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Reseñas por Mes",
       y = "Reseñas por Mes",
       x = "") +
  theme_minimal()

# Boxplot para Rooms.rent.by.the.host
ggplot(airbnb_data, aes(y = Rooms.rent.by.the.host)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Habitaciones alquiladas por el host",
       y = "Habitaciones alquiladas por el host",
       x = "") +
  theme_minimal()

```

```{r}
# Obtener un resumen de las columnas numéricas
summary(airbnb_data[sapply(airbnb_data, is.numeric)])
```

```{r}
library(ggplot2)

#Histogramas

# Gráfico para Room.type
ggplot(airbnb_data, aes(x = Room.type)) +
  geom_bar(fill = "coral") +
  labs(title = "Distribución por Tipo de Habitación", x = "Tipo de Habitación", y = "Frecuencia")

# Gráfico para City
ggplot(airbnb_data, aes(x = City)) +
  geom_bar(fill = "lightgreen") +
  labs(title = "Distribución por Ciudad", x = "Ciudad", y = "Frecuencia")

# Gráfico para Country
ggplot(airbnb_data, aes(x = Country)) +
  geom_bar(fill = "gold") +
  labs(title = "Distribución por País", x = "País", y = "Frecuencia")

# Gráfico para Availability_Cat
ggplot(airbnb_data, aes(x = Availability_Cat)) +
  geom_bar(fill = "purple") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución por Categoría de Disponibilidad", x = "Categoría de Disponibilidad", y = "Frecuencia")

# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Time_category)) +
  geom_bar(fill = "yellow") +
  labs(title = "Distribución de Time_category", x = "Time_category", y = "Frecuencia")

# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Review_category)) +
  geom_bar(fill = "green") +
  labs(title = "Distribución de Review_category", x = "Review_category", y = "Frecuencia")

# Grafico para barrio  

ggplot(airbnb_data, aes(y = Neighbourhood)) +
  geom_bar() +
  theme(axis.text.y = element_text(size = 5)) +
  labs(title = "Distribución por Vecindario", x = "Frecuencia", y = "Vecindario")



```

```{r}
# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Room.Price)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Precios", x = "Precio", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Minimum.nights)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Minimum.nights", x = "Minimum.nights", y = "Densidad")

```

```{r}

#Room.price


# Transformación Logaritmica

airbnb_data <- mutate(airbnb_data,
                      Room_Price_Log = log(Room.Price + 1))

# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Room_Price_Log)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Precios", x = "Precio", y = "Densidad")
```

```{r}
#Minimum.nights


# Transformación Logaritmica

airbnb_data <- mutate(airbnb_data,
                      Minimum_nights_Log = log(Minimum.nights + 1))

# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Minimum_nights_Log)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Minimum Nights", x = "Minimum Nights", y = "Densidad")
```

```{r}
#Number.of.reviews


# Transformación Logaritmica

airbnb_data <- mutate(airbnb_data,
                      Number_of_reviews_Log = log(Number.of.reviews + 1))

# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Number_of_reviews_Log)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Number of reviews", x = "Number of reviews", y = "Densidad")
```

```{r}

#Number.of.reviews.per.month


# Transformación Logaritmica

airbnb_data <- mutate(airbnb_data,
                      Number_of_reviews_per_month_Log = log(Number.of.reviews.per.month + 1))

# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Number_of_reviews_per_month_Log)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Reviews per Month", x = "Reviews per Month", y = "Densidad")
```

```{r}

#Rooms.rent.by.the.host


# Transformación Logaritmica

airbnb_data <- mutate(airbnb_data,
                      Rooms_rent_by_the_host_Log = log(Rooms.rent.by.the.host + 1))

# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Rooms_rent_by_the_host_Log)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Rooms rent by the host", x = " Rooms rent by the host", y = "Densidad")
```

### Gráficos

```{r}
# Instalar paquetes si no están instalados
if (!require("readxl")) install.packages("readxl")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("ggmap")) install.packages("ggmap")
if (!require("dplyr")) install.packages("dplyr")

# Cargar paquetes
library(readxl)
library(ggplot2)
library(corrplot)
library(ggmap)
library(dplyr)

```

#### Gráfico de Distribución en Madrid

Las columnas `Latitude` y `Longitude` están disponibles, podemos crear un mapa de puntos en Madrid:

```{r}
# Instalar y cargar el paquete leaflet si no está ya instalado
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)

# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir marcadores con clústeres y capas por barrio
for (neighbourhood in unique(airbnb_data$Neighbourhood)) {
  neighbourhood_data <- airbnb_data[airbnb_data$Neighbourhood == neighbourhood,]
  madrid_map <- madrid_map |>
    addCircleMarkers(
      data = neighbourhood_data,
      lng = ~Longitude,
      lat = ~Latitude,
      radius = ~ifelse(Room.Price > 100, 8, 5), # Diferente tamaño basado en el precio
      color = ~colorBin(palette = c("yellow", "red", "green"), bins = 5, Room.Price),
      popup = ~paste("Precio: ", Room.Price, "€", "<br>",
                     "Noches mínimas: ", Minimum.nights, "<br>",
                     "Reseñas: ", Number.of.reviews),
      clusterOptions = markerClusterOptions(),
      group = neighbourhood
    )
}

# Añadir control de capas para seleccionar o deseleccionar barrios
madrid_map <- madrid_map |>
  addLayersControl(
    overlayGroups = unique(airbnb_data$Neighbourhood),
    options = layersControlOptions(collapsed = FALSE)
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 12)

# Imprimir el mapa
madrid_map





```

```{r}
# Instalar y cargar los paquetes necesarios
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)
if (!require("leaflet.extras")) install.packages("leaflet.extras")
library(leaflet.extras)


# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir la capa de mapa de calor
madrid_map <- madrid_map |>
  addHeatmap(
    lng = ~Longitude, lat = ~Latitude, intensity = ~1,
    blur = 20, max = 0.05, radius = 15
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map

```

```{r}
# Cargar el paquete dplyr para manipulación de datos
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)

# Definir una función para determinar el color basado en el precio
get_color <- function(price) {
  if (price < 50) {
    "#00FF00"  # Verde para precios bajos
  } else if (price < 100) {
    "#FFFF00"  # Amarillo para precios medios
  } else {
    "#FF0000"  # Rojo para precios altos
  }
}

# Añadir una nueva columna al dataset con los colores calculados
airbnb_data <- airbnb_data %>%
  mutate(Color = sapply(Room.Price, get_color))

# Crear el mapa
library(leaflet)

madrid_map <- leaflet(data = airbnb_data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    ~Longitude, ~Latitude,
    radius = 5,
    color = ~Color,
    fillOpacity = 0.5,
    stroke = FALSE,  # No dibujar bordes alrededor de los círculos
    group = "Airbnb Locations"
  ) %>%
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map


```

#### Mapa de Calor de Correlación

Para el mapa de calor de correlación, seleccionamos las columnas numéricas relevantes.

```{r}

# Instalar paquetes si no están instalados
if (!require("dplyr")) install.packages("dplyr")
if (!require("corrplot")) install.packages("corrplot")

library(dplyr)
library(corrplot)

# Seleccionando columnas relevantes para la correlación
cor_data <- airbnb_data |>
  select(Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host) |>
  na.omit()  # Eliminando filas con valores NA para evitar errores

# Calculando la matriz de correlación
cor_matrix <- cor(cor_data)

# Generando el mapa de calor
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45, addrect = 2, 
         title = "Mapa de Calor de Correlación para AirBnB en Madrid",
         mar = c(0, 0, 2, 0))  # Ajusta el margen superior para dar más espacio al título


```

```{r}

if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "airbnb_data_madrid_final_9_may.xlsx")

```
