---
title: "cuaderno"
format: html
editor: visual
---

# Análisis Exploratorio de Dataset de Airbnb (Madrid-España)

Vamos a trabajar con el dataset air-bnb-listings.csv, que contiene información sobre alojamientos disponibles en la plataforma Airbnb, concretamente de Madrid(España).

En primer lugar, leemos el dataset, se especifica que el separador de campos es un punto y coma.

```{r}
library(tidyverse)

# Leer el archivo CSV
airbnb_data <- read.csv("../data/raw/air-bnb-listings.csv", sep = ';')

```

Mostramos las primeras filas del dataset. Esto nos permite comprobar que los datos se han cargado correctamente.

```{r}
# Ver las primeras filas de los datos
head(airbnb_data)

```

Creamos un resumen estadístico del DataFrame, que incluye varias métricas para cada columna.

```{r}
# Resumen estadístico y estructura del DataFrame
summary(airbnb_data)
```

Calculamos y mostramos las dimensiones originales del dataset, obteniendo el número de filas y columnas.

```{r}
dimension_original <- dim(airbnb_data)

paste('El numero de filas que tiene el dataframe airbnb_data es:', dimension_original[1])
paste('El numero de columnas que tiene el dataframe airbnb_data es:', dimension_original[2])
```

Mostramos los nombres de las columnas.

```{r}
colnames(airbnb_data)
```

Creamos un DataFrame que muestre la informacion sobre la clase y el tipo de datos de cada columna.

```{r}

# Crear un vector con los nombres de las columnas
column_names <- colnames(airbnb_data)

# Obtener la clase y el tipo de cada columna utilizando sapply
column_classes <- sapply(airbnb_data, class)
column_types <- sapply(airbnb_data, typeof)

# Crear el dataframe con la información recopilada de Type y Clase 
clase_tipo <- data.frame(
  Class = column_classes,      # Clase de cada columna
  Type = column_types          # Tipo de cada columna
)

# Ver los resultados
print(clase_tipo)


```

## Conversión de variables

Convertimos las columnas con fechas (Data.last.review y Update.Date) a tipo Date(Fecha).

```{r}

# Convertir la columna Date.last.review a tipo fecha
airbnb_data$Date.last.review <- as.Date(airbnb_data$Date.last.review, format = "%Y-%m-%d")

# Convertir la columna Updated.Date a tipo fecha
airbnb_data$Updated.Date <- as.Date(airbnb_data$Updated.Date, format = "%Y-%m-%d")

```

Convertimos algunas columnas del conjunto de datos en variables categóricos (factores) ya que está transformación nos va a permitir tratar las variables  `Room.type, Neighbourhood, City y Country`, como categorías discretas en vez de datos continuos. Facilitando así el análisis y la visualización.

```{r}

# Convertir columnas seleccionadas a factores (categóricas)
airbnb_data$Room.type <- as.factor(airbnb_data$Room.type)
airbnb_data$Neighbourhood <- as.factor(airbnb_data$Neighbourhood)
airbnb_data$City <- as.factor(airbnb_data$City)
airbnb_data$Country <- as.factor(airbnb_data$Country)
```

Nos aseguramos que los cambios se han hecho bien:

```{r}
# Crear un vector con los nombres de las columnas
column_names <- colnames(airbnb_data)

# Obtener la clase y el tipo de cada columna utilizando sapply
column_classes <- sapply(airbnb_data, class)
column_types <- sapply(airbnb_data, typeof)

# Crear el dataframe con la información recopilada de Type y Clase 
clase_tipo <- data.frame(
  Class = column_classes,      # Clase de cada columna
  Type = column_types          # Tipo de cada columna
)

# Ver los resultados
print(clase_tipo)

```

### Availibility

La columna Availibility la convertimos en una variable categórica con rangos específicos para poder categorizar los niveles de disponibilidad en rangos predefinidos y así facilitar el análisis y la visualización. Revisamos también la columna añadida para comprobar que la categorización era adecuada.

```{r}


# Rangos de disponibilidad y sus etiquetas
breaks <- c(-1, 0, 30, 60, 90, 180, 365)
labels <- c("No disponible", "Menos de 30 días", "31 a 60 días", "61 a 90 días", "91 a 180 días", "181 a 365 días")

# Categorizar 'Availability' usando cut()
airbnb_data$Availability_Cat <- cut(airbnb_data$Availibility, breaks = breaks, labels = labels, include.lowest = TRUE)


airbnb_data$Availability_Cat<- as.factor(airbnb_data$Availability_Cat)

summary(airbnb_data$Availability_Cat)


```

### City

Hicimos un filtrado en el que solo mantuvimos las filas donde el valor de la columna City era Madrid.

```{r}
library(dplyr)


ciudad <- as.data.frame(table(airbnb_data$City)) 

print(ciudad)

# Filtrar el dataset para mantener solo las filas donde la ciudad es Madrid
airbnb_data <- airbnb_data %>% filter(City == "Madrid")

# Verificar que sólo quedan entradas de Madrid en el dataset original
ciudad <- as.data.frame(table(airbnb_data$City)) 
print(ciudad)

# Verificar las dimensiones del dataset actualizado
dimension_solo_madrid <- dim(airbnb_data)

paste("El dataset original tenía:", dimension_original[1], "observaciones. Tras eliminar los registros que no eran de Madrid, el numero de observaciones es de:",dimension_solo_madrid[1], ". Se han eliminadas:", dimension_original[1] - dimension_solo_madrid[1], "registros" )


```

### Coordinates

La columna Coordinates la dividimos en dos columnas, Latitude y Longitude para poder representar las coordenadas geográficas.

```{r}
# Asegurándonos de que la columna Coordinates está en formato de string
airbnb_data$Coordinates <- as.character(airbnb_data$Coordinates)

# Separar la columna Coordinates en dos nuevas columnas: Latitude y Longitude
airbnb_data<- airbnb_data %>%
  separate(Coordinates, into = c("Latitude", "Longitude"), sep = ",", convert = TRUE)

paste("La columna Coordinates se ha dividido en 2 :'Latitude', 'Longitude'")

if (!require(tibble)) {
    install.packages("tibble")
}
library(tibble)

# Crear un tibble con los tipos y clases de las columnas Latitud y Longitud
column_info <- tibble(
    Column = c("Latitude", "Longitude"),
    Type_of_Data = c(typeof(airbnb_data$Latitude), typeof(airbnb_data$Longitude)),
    Class_of_Data = c(class(airbnb_data$Latitude), class(airbnb_data$Longitude))
)

# Mostrar el tibble
print(column_info)


```

### Location

Parece que la columna `Location` es la combinación de `Country, City, y Neighbourhood`. Vamos a probarlo:

```{r}

library(dplyr)

#Crear una nueva columna temporal que combine Country,City y Neighbourhood para ver si coincide exactamente con la columna Location.

airbnb_data <- airbnb_data |> mutate(Combined = paste(Country, City, Neighbourhood, sep = ", "))

#Comparar la columna Location con la columna Combined para verificar si son iguales.

airbnb_data <- airbnb_data |> mutate(Location_Match = Location == Combined)


#Revisa cuántos y qué porcentaje de las filas tienen coincidencia exacta entre Location y la columna combinada.

table(airbnb_data$Location_Match)

paste("Si concatenamos Country,City y Neighbourhood nos da el mismo resultado que la columna Location, por lo que podemos eliminarla")

```

Se comparó la columna Location con la combinación de Country, City, y Neighbourhood, y se concluyó que era redundante por lo que se procedió a su eliminación.

### Date.last.review

```{r}

# Calcular el número de días desde la última revisión hasta la fecha de extracción
date_scraped <- as.Date("2020-07-17")
airbnb_data$time_since_last_review <- as.numeric(difftime(date_scraped, airbnb_data$Date.last.review, units = "days"))

# Histograma del tiempo transcurrido desde la última reseña
ggplot(airbnb_data, aes(x = time_since_last_review)) +
  geom_histogram(bins = 30, fill = "#69b3a2", color = "#e9ecef") + # Colores personalizados para las barras
  theme_minimal() +
  theme(
    text = element_text(family = "Helvetica", size = 12), # Cambia la fuente y el tamaño del texto
    plot.title = element_text(face = "bold", hjust = 0.5), # Negrita y centrado para el título
    plot.subtitle = element_text(face = "italic", hjust = 0.5), # Subtítulo en cursiva y centrado
    axis.title = element_text(face = "bold", size = 13) # Títulos de los ejes en negrita y tamaño aumentado
  ) +
  labs(
    title = "Distribución de días desde la última reseña",
    subtitle = "Visualización de la frecuencia de días transcurridos",
    x = "Días desde la última reseña", y = "Frecuencia"
  )

```

```{r}
library(dplyr)

airbnb_data <- airbnb_data %>%
  mutate(
    Time_category = factor(
      if_else(
        is.na(time_since_last_review),
        'sin reseñas',  # Asignar directamente 'sin reseñas' si el valor es NA
        cut(  # Usar cut solo en valores no-NA
          time_since_last_review,
          breaks = c(0, 14, 60, 182, 365, Inf),  # Definiendo los rangos
          labels = c('0-2 semanas', '2-8 semanas', '2-6 meses', '6-12 meses', '1+ año'),
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', '0-2 semanas', '2-8 semanas', '2-6 meses', '6-12 meses', '1+ año')
    )
  )



summary(airbnb_data$Time_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-2 semanas, incluye los valores desde 0 a 14 (incluido)
#El intervalo 2-8 semanas, incluye los valores desde 15 a 60 (incluido)  y asi sucesivamente 

```

## Estudio de los valores nulos y ceros.

Creamos un dataframe con los resultados de la contabilizacion por columnas, de nulos y ceros.

```{r}
# Dataframe con la contabilizacion de Nulos y Ceros
resultados <- data.frame(
  NA_Count = colSums(is.na(airbnb_data)),
  Zero_Count = colSums(airbnb_data == 0, na.rm = TRUE)
)

resultados
```

Vemos que existe la misma cantidad de ceros en `Number.of.reviews`, que nulos en `Date.last.review` y `Number.of.reviews.per.month.`

¿Están relacionados estos tres valores?

```{r}

# Añadir una columna temporal para verificar la condición
airbnb_data <- airbnb_data |>
  mutate(
    check = Number.of.reviews == 0 & is.na(Date.last.review) & is.na(Number.of.reviews.per.month)
  )

# Sumar para comprobar la condición basada en Number.of.reviews
result <- airbnb_data %>%
  filter(Number.of.reviews == 0) %>%
  summarise(
    Total_Zero_Reviews = n(),
    Correct_Cases = sum(check)
  )

print(result)



```

Hemos añadido una columna llamada 'check' a nuestro conjunto de datos. Esta columna nos ayuda a ver si el número de reseñas es cero y, al mismo tiempo, si las fechas de la última reseña y el promedio de reseñas por mes están vacíos. Si se cumplen estas condiciones, la columna indica 'verdadero'; si no, muestra 'falso'.

Comparamos la cuenta de los registros donde el número de reseñas es cero, con el número de cuántos de registros que no solo están sin reseñas, sino que también carecen de fecha de última reseña y de promedio de reseñas por mes. Este paso nos permite comprobar si nuestra teoría sobre la relación entre estas variables se sostiene. Tiene sentido, ya que si un alojamiento no ha recibido reseñas, no podría tener una fecha de última reseña ni un promedio de reseñas mensuales.

Una vez probados esto, para poder hacer un mejor tratamiento de datos, vamos a colocar en los valores nulos de `Number.of.reviews.per.month.`ceros.

```{r}
# Sustituir directamente los NA por 0 en la columna específica
airbnb_data$Number.of.reviews.per.month[is.na(airbnb_data$Number.of.reviews.per.month)] <- 0
```

Ahora voy a categorizar `Number.of.reviews.per.month` para un mejor análisis

```{r}
library(dplyr)

# Asumiendo que airbnb_data ya está cargado.

airbnb_data <- airbnb_data %>%
  mutate(
    Review_category = factor(
      if_else(
        is.na(Number.of.reviews.per.month) | Number.of.reviews.per.month == 0,  # Condición para NA o cero
        'sin reseñas',  # Valor si la condición es verdadera
        cut(  # Función cut para categorizar los valores no NA y no cero
          Number.of.reviews.per.month,
          breaks = c(0, 1, 5, 10, 20, Inf),  # Puntos de corte para las categorías
          labels = c('0-1/mes', '1-5/mes', '5-10/mes', '10-20/mes', '20+ mes'),  # Etiquetas para cada rango
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', '0-1/mes', '1-5/mes', '5-10/mes', '10-20/mes', '20+ mes')  # Definiendo el orden de los niveles del factor
    )
  )


summary(airbnb_data$Review_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-1/mes, incluye los valores desde 0.01 a 1 (incluido)
#El intervalo 1-5/mes, incluye los valores desde 1,01 a 5 (incluido) y asi sucesivamente 
```

Haremos lo mismo con `Number.of.reviews`

```{r}
library(dplyr)

airbnb_data <- airbnb_data %>%
  mutate(
    Review_Count_Category = factor(
      if_else(
        Number.of.reviews == 0,  # Condición para verificar si hay 0 reseñas
        'sin reseñas',  # Etiqueta para 0 reseñas
        cut(  # Usar cut para valores mayores a 0
          Number.of.reviews,
          breaks = c(0, 1, 10, 50, 100, 500, Inf),  # Ajuste de los rangos para incluir 1 correctamente
          labels = c('1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas'),
          include.lowest = TRUE,
          right = TRUE  # Cambio a TRUE para incluir el valor 1 en la categoría '1 reseña'
        )
      ),
      levels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas')  # Definición explícita del orden de los niveles
    )
  )

# Puedes verificar el resultado con:
summary(airbnb_data$Review_Count_Category)


#NOTA: 
#El intervalo sin reseñas, incluye todos los ceros
#El intervalo1 reseña, incluye solos los valor 1 
#El intervalo '2-10 reseñas', incluye los valores desde 2 a 10 (incluido)
#El intervalo '11-50 reseñas', incluye los valores desde 11 a 50 (incluido) y asi sucesivamente 


```

Por otro lado los ceros de **`Availibility`**, se han tratado en la columna **`Availibility_cat`** como alojamientos "No disponibles"

### Resumen cambios en las variables.

Por supuesto, aquí tienes un resumen más condensado de los cambios realizados en cada columna de tu conjunto de datos:

#### 1. **Date.last.review & Updated.Date**

-   Convertidas a formato de fecha (`%Y-%m-%d`).

-   *Date.last.review* - Resta entre Fecha del Scrapping y *Date.last.review*. Se guarda en *Time_category* y se categorizada en rangos de tiempo:

    -   Las categorías para esta variable son:
    -   "sin reseñas"
    -   "0-2 semanas"
    -   "2-8 semanas"
    -   "2-6 meses"
    -   "6-12 meses"
    -   "1+ año"

#### 2. **Room.type, Neighbourhood, City, Country**

-   Transformadas en variables categóricas (factores).

#### 3. **Availability**

-   Categorizada en rangos desde 'No disponible' hasta '181 a 365 días'. Así:

    -   "No disponible" - Para los alojamientos con cero días.
    -   "Menos de 30 días"
    -   "31 a 60 días"
    -   "61 a 90 días"
    -   "91 a 180 días"
    -   "181 a 365 días"

#### 4. **City**

-   Filtrados datos para incluir solo entradas de Madrid.

#### 5. **Coordinates**

-   Separada en dos columnas numéricas: Latitude y Longitude.

#### 6. **Location**

-   Comprobada por redundancia y eliminada tras confirmar duplicidad con Country, City, y Neighbourhood.

#### 7. **Number.of.reviews & Number.of.reviews.per.month**

-   Análisis de valores nulos y ceros; categorizados en rangos para facilitar análisis.

##### **Review_category** (creado a partir de `Number.of.reviews.per.month`)

-   Las categorías son:
    -   "sin reseñas"
    -   "0-1/mes"
    -   "1-5/mes"
    -   "5-10/mes"
    -   "10-20/mes"
    -   "20+ mes"

##### **Review_Count_Category** (creado a partir de `Number.of.reviews`)

-   Las categorías son:
    -   "sin reseñas"
    -   "1 reseña"
    -   "2-10 reseñas"
    -   "11-50 reseñas"
    -   "51-100 reseñas"
    -   "101-500 reseñas"
    -   "500+ reseñas"

```{r}
# Cargar la librería necesaria
library(ggplot2)

# Boxplot para Room.Price
ggplot(airbnb_data, aes(y = Room.Price)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = "Distribución del Precio de la Habitación",
       y = "Precio (€)",
       x = "") +
  theme_minimal()

# Boxplot para Minimum.nights
ggplot(airbnb_data, aes(y = Minimum.nights)) +
  geom_boxplot(fill = "lightgreen", color = "darkgreen") +
  labs(title = "Distribución del Número Mínimo de Noches Requeridas",
       y = "Número Mínimo de Noches",
       x = "") +
  theme_minimal()

# Boxplot para Number.of.reviews
ggplot(airbnb_data, aes(y = Number.of.reviews)) +
  geom_boxplot(fill = "lightcoral", color = "darkred") +
  labs(title = "Distribución del Número de Reseñas",
       y = "Número de Reseñas",
       x = "") +
  theme_minimal()

# Boxplot para Number.of.reviews.per.month
ggplot(airbnb_data, aes(y = Number.of.reviews.per.month)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Reseñas por Mes",
       y = "Reseñas por Mes",
       x = "") +
  theme_minimal()

# Boxplot para Rooms.rent.by.the.host
ggplot(airbnb_data, aes(y = Rooms.rent.by.the.host)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Habitaciones alquiladas por el host",
       y = "Habitaciones alquiladas por el host",
       x = "") +
  theme_minimal()

```

```{r}
# Obtener un resumen de las columnas numéricas
summary(airbnb_data[sapply(airbnb_data, is.numeric)])
```

```{r}
library(ggplot2)

#Histogramas

# Gráfico para Room.type
ggplot(airbnb_data, aes(x = Room.type)) +
  geom_bar(fill = "coral") +
  labs(title = "Distribución por Tipo de Habitación", x = "Tipo de Habitación", y = "Frecuencia")

# Gráfico para City
ggplot(airbnb_data, aes(x = City)) +
  geom_bar(fill = "lightgreen") +
  labs(title = "Distribución por Ciudad", x = "Ciudad", y = "Frecuencia")

# Gráfico para Country
ggplot(airbnb_data, aes(x = Country)) +
  geom_bar(fill = "gold") +
  labs(title = "Distribución por País", x = "País", y = "Frecuencia")

# Gráfico para Availability_Cat
ggplot(airbnb_data, aes(x = Availability_Cat)) +
  geom_bar(fill = "purple") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución por Categoría de Disponibilidad", x = "Categoría de Disponibilidad", y = "Frecuencia")

# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Time_category)) +
  geom_bar(fill = "yellow") +
  labs(title = "Distribución de Time_category", x = "Time_category", y = "Frecuencia")

# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Review_category)) +
  geom_bar(fill = "green") +
  labs(title = "Distribución de Review_category", x = "Review_category", y = "Frecuencia")

# Grafico para barrio  

ggplot(airbnb_data, aes(y = Neighbourhood)) +
  geom_bar() +
  theme(axis.text.y = element_text(size = 5)) +
  labs(title = "Distribución por Vecindario", x = "Frecuencia", y = "Vecindario")



```

```{r}
# Cargar el paquete ggplot2
library(ggplot2)

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Room.Price)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Precios", x = "Precio", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Minimum.nights)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Minimum.nights", x = "Minimum.nights", y = "Densidad")

```

### Gráficos

```{r}
# Instalar paquetes si no están instalados
if (!require("readxl")) install.packages("readxl")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("ggmap")) install.packages("ggmap")
if (!require("dplyr")) install.packages("dplyr")

# Cargar paquetes
library(readxl)
library(ggplot2)
library(corrplot)
library(ggmap)
library(dplyr)

```

#### **Histograma del vecindario en términos de distritos**

```{r}

library(ggplot2)

ggplot(airbnb_data, aes(x = Neighbourhood)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Histograma del Vecindario en Términos de Distritos", 
       x = "Distrito", 
       y = "Frecuencia") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Primero se establece el dataframe airbnb_data como el conjunto de datos para el gráfico y mapea la variable Neighbourhood en el eje x del gráfico. Después se añade un gráfico de barras al gráfico base. Elegí  el color de relleno de las barras como "skyblue" y el color de borde como "black".

labs(title = "Histograma del Vecindario en Términos de Distritos", x = "Distrito", y = "Frecuencia"): Esta función establece el título del gráfico como "Histograma del Vecindario en Términos de Distritos" y etiqueta los ejes x e y como "Distrito" y "Frecuencia", respectivamente.

\
**Distribución de precio vs número de reseñas**\

Configura el dataframe airbnb_data para el gráfico y mapea el precio de la habitación en el eje x y el número de reseñas en el eje y.Agregamos puntos al gráfico base para mostrar la distribución de los datos. Y establece el título del gráfico como "Distribución de Precio vs Número de Reseñas".

\

```{r}
ggplot(airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) +

geom_point(color = "blue") +

labs(title = "Distribución de Precio vs Número de Reseñas", x = "Precio de la Habitación (€)", y = "Número de Reseñas")


```

\
**Precio promedio vs tipo de habitación**\

```{r}
ggplot(airbnb_data, aes(x = Room.type, y = Room.Price)) +

geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "darkgreen") +

labs(title = "Precio Promedio vs Tipo de Habitación", x = "Tipo de Habitación", y = "Precio Promedio (€)")


```

\
Configura el dataframe airbnb_data para el gráfico y mapea el tipo de habitación en el eje x y el precio de la habitación en el eje y. Luego agrega un gráfico de barras al gráfico base. Calcula la media del precio de la habitación para cada tipo de habitación y usa "skyblue" como color de relleno. Ystablece el título del gráfico como "Precio Promedio vs Tipo de Habitación" y etiqueta los ejes x e y como "Tipo de Habitación" y "Precio Promedio", respectivamente.

\

#### Tipo de propiedad y áreas (distritos) 

```{r}
# Crear un gráfico de barras apiladas 

ggplot(data = airbnb_data, aes(x = Neighbourhood, fill = `Room.type`)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Cantidad") + ggtitle("Distribución de tipos de propiedad por distritos en Madrid")
```

El gráfico muestra la distribución de los diferentes tipos de propiedades en cada distrito de Madrid. Cada barra representa un distrito y los segmentos de cada barra están coloreados para representar los diferentes tipos de propiedad. Los segmentos de cada barra se apilan unos sobre otros.

#### Distribución de precios vs distrito 

```{r}
ggplot(data = airbnb_data, aes(x = Neighbourhood, y = Room.Price)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Precio") + ggtitle("Distribución de precios por distrito en Madrid")
```

\
Este gráfico representa la distribución de los precios para cada distrito. Cada caja muestra la distribución de los precios en un distrito específico, donde la línea en el centro de la caja representa la mediana de los precios. Los puntos individuales fuera de los bigotes representan valores atípicos potenciales.

#### Tendencia mediana y puntuación de reseñas 

```{r}
ggplot(data = airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) + geom_point() + geom_smooth(method = "lm", se = FALSE, color = "red") + labs(x = "Precio", y = "Puntuación  de reseñas") + ggtitle("Tendencia de la mediana de precios por puntuación de reseñas por distrito en Madrid")
```

\
Este gráfico muestra la relación entre el precio y el puntuación de las reseñas recibidas. Cada punto en el gráfico representa un listado individual, donde la posición horizontal del punto indica el precio y la posición vertical indica el número de reseñas.

El gráfico incluye una línea de tendencia (en rojo) ajustada mediante un modelo de regresión lineal. Esta línea de tendencia representa la tendencia general entre el precio y el número de reseñas: si la línea de tendencia tiene una pendiente positiva, indica una relación positiva entre el precio y el número de reseñas, mientras que una pendiente negativa indica una relación negativa.

\
\

#### 

#### 

\

#### Gráfico de Distribución en Madrid

Las columnas `Latitude` y `Longitude` están disponibles, podemos crear un mapa de puntos en Madrid:

```{r}
# Instalar y cargar el paquete leaflet si no está ya instalado
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)

# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir marcadores con clústeres y capas por barrio
for (neighbourhood in unique(airbnb_data$Neighbourhood)) {
  neighbourhood_data <- airbnb_data[airbnb_data$Neighbourhood == neighbourhood,]
  madrid_map <- madrid_map |>
    addCircleMarkers(
      data = neighbourhood_data,
      lng = ~Longitude,
      lat = ~Latitude,
      radius = ~ifelse(Room.Price > 100, 8, 5), # Diferente tamaño basado en el precio
      color = ~colorBin(palette = c("yellow", "red", "green"), bins = 5, Room.Price),
      popup = ~paste("Precio: ", Room.Price, "€", "<br>",
                     "Noches mínimas: ", Minimum.nights, "<br>",
                     "Reseñas: ", Number.of.reviews),
      clusterOptions = markerClusterOptions(),
      group = neighbourhood
    )
}

# Añadir control de capas para seleccionar o deseleccionar barrios
madrid_map <- madrid_map |>
  addLayersControl(
    overlayGroups = unique(airbnb_data$Neighbourhood),
    options = layersControlOptions(collapsed = FALSE)
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 12)

# Imprimir el mapa
madrid_map





```

```{r}
# Instalar y cargar los paquetes necesarios
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)
if (!require("leaflet.extras")) install.packages("leaflet.extras")
library(leaflet.extras)


# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir la capa de mapa de calor
madrid_map <- madrid_map |>
  addHeatmap(
    lng = ~Longitude, lat = ~Latitude, intensity = ~1,
    blur = 20, max = 0.05, radius = 15
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map

```

```{r}
# Cargar el paquete dplyr para manipulación de datos
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)

# Definir una función para determinar el color basado en el precio
get_color <- function(price) {
  if (price < 50) {
    "#00FF00"  # Verde para precios bajos
  } else if (price < 100) {
    "#FFFF00"  # Amarillo para precios medios
  } else {
    "#FF0000"  # Rojo para precios altos
  }
}

# Añadir una nueva columna al dataset con los colores calculados
airbnb_data <- airbnb_data %>%
  mutate(Color = sapply(Room.Price, get_color))

# Crear el mapa
library(leaflet)

madrid_map <- leaflet(data = airbnb_data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    ~Longitude, ~Latitude,
    radius = 5,
    color = ~Color,
    fillOpacity = 0.5,
    stroke = FALSE,  # No dibujar bordes alrededor de los círculos
    group = "Airbnb Locations"
  ) %>%
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map


```

#### Mapa de Calor de Correlación

Para el mapa de calor de correlación, seleccionamos las columnas numéricas relevantes.

```{r}

# Instalar paquetes si no están instalados
if (!require("dplyr")) install.packages("dplyr")
if (!require("corrplot")) install.packages("corrplot")

library(dplyr)
library(corrplot)

# Seleccionando columnas relevantes para la correlación
cor_data <- airbnb_data |>
  select(Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host) |>
  na.omit()  # Eliminando filas con valores NA para evitar errores

# Calculando la matriz de correlación
cor_matrix <- cor(cor_data)

# Generando el mapa de calor
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45, addrect = 2, 
         title = "Mapa de Calor de Correlación para AirBnB en Madrid",
         mar = c(0, 0, 2, 0))  # Ajusta el margen superior para dar más espacio al título


```

```{r}

if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "airbnb_data_madrid_final_9_may.xlsx")

```
