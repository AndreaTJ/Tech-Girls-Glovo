---
title: "cuaderno"
format: html
editor: visual
---

# Análisis Exploratorio de Dataset de Airbnb (Madrid-España)

Este análisis explora un conjunto de datos de Airbnb, específicamente centrado en las listas de alojamientos disponibles en Madrid, España. Los datos han sido descargados desde el portal público OpenDataSoft, una plataforma que facilita el acceso a diversos datasets abiertos para análisis y aplicaciones de datos. Puedes acceder directamente al dataset utilizado a través del siguiente enlace: [Airbnb Listings en OpenDataSoft](https://public.opendatasoft.com/explore/dataset/air-bnb-listings/table/?disjunctive.neighbourhood&disjunctive.column_10&disjunctive.city&q=Madrid&location=7,40.5931,-4.422&basemap=jawg.light).

En primer lugar, leemos el dataset, se especifica que el separador de campos es un punto y coma.

```{r}
library(tidyverse)

# Leer el archivo CSV
airbnb_data_raw <- read.csv("../data/raw/air-bnb-listings.csv", sep = ';')

```

Mostramos las primeras filas del dataset. Esto nos permite comprobar que los datos se han cargado correctamente.

```{r}
# Ver las primeras filas de los datos
head(airbnb_data_raw)

```

Calculamos y mostramos las dimensiones originales del dataset, obteniendo el número de filas y columnas.

```{r}
dimension_original <- dim(airbnb_data_raw)

paste('El numero de filas que tiene el dataframe airbnb_data es:', dimension_original[1])
paste('El numero de columnas que tiene el dataframe airbnb_data es:', dimension_original[2])
```

El dataset original, tiene `17 variables(columnas)` y `21278 observaciones(filas).`

Examinamos que tipo de variables tenemos.

```{r}
str(airbnb_data_raw)
```

Vemos que tenemos variables categóricas como `Room.type, Neighbourhood, City y Country` que no se están tomando como tal, sino como `character`. Lo mismo sucede con las fechas.

Para tener más visibilidad del tipo y clase de dato que tiene cada columna, creamos un DataFrame que muestre la informacion sobre la clase y el tipo de datos de cada variable.

```{r}

# Función para obtener las clases y tipos de las columnas de un dataframe
obtener_clase_tipo <- function(data) {
  # Crear un vector con los nombres de las columnas
  column_names <- colnames(data)

  # Obtener la clase y el tipo de cada columna utilizando sapply
  column_classes <- sapply(data, class)
  column_types <- sapply(data, typeof)

  # Crear el dataframe con la información recopilada de Clase y Tipo
  clase_tipo <- data.frame(
    Class = column_classes,     # Clase de cada columna
    Type = column_types         # Tipo de cada columna
  )
  
  # Devolver el dataframe
  return(clase_tipo)
}

# Usar la función con el dataframe airbnb_data
resultado_clase_tipo <- obtener_clase_tipo(airbnb_data_raw)
print(resultado_clase_tipo)



```

Con esta información, vamos a proceder a hacer las conversiones necesarias:

## `Conversión de variables`

Para asegurar la integridad del dataframe original mientras realizamos cambios, primero crearemos una copia del mismo. Todas las modificaciones y análisis se realizarán en esta copia, denominada **`airbnb_data`**.

```{r}
airbnb_data <- data.frame(airbnb_data_raw)

```

Como hemos visto arriba, hay columnas que deberían ser de diferente clase.

```{r}
str(airbnb_data[, c("Date.last.review", "Updated.Date", "Room.type", "Neighbourhood", "City", "Country")])
```

**`Data.last.review y Update.Date`.**

**Deberían ser fecha:** Ya que ambas variables permiten cálculos como la diferencia de días entre eventos, agrupación por períodos de tiempo (por ejemplo, mes, año), y correlacionar eventos o cambios con fechas específicas, lo cual sería difícil si estas variables fueran tratadas de otra manera (como character por ejemplo).

**`Room.type, Neighbourhood, City y Country`**

**Deberían ser categóricas:** Ya que agrupan los datos usando etiquetas textuales y facilitan análisis por segmentos. Además, no representan cantidades ni establecen un orden, características típicas de las variables categóricas.

### `Data.last.review y Update.Date`

Convertimos ambas columnas a fechas:

```{r}

# Convertir la columna Date.last.review a tipo fecha
airbnb_data$Date.last.review <- as.Date(airbnb_data$Date.last.review, format = "%Y-%m-%d")

# Convertir la columna Updated.Date a tipo fecha
airbnb_data$Updated.Date <- as.Date(airbnb_data$Updated.Date, format = "%Y-%m-%d")

```

Comprobamos que se ha realizado con éxito el cambio:

```{r}
str(airbnb_data[, c("Date.last.review", "Updated.Date")])

```

Como podemos comprobar arriba, el cambio se hizo correctamente. `Data.last.review y Update.Date` son ahora fechas.

### `Room.type, Neighbourhood, City y Country`

Convertimos estas variables en categóricas.

```{r}

# Convertir columnas a factores (categóricas)
airbnb_data$Room.type <- as.factor(airbnb_data$Room.type)
airbnb_data$Neighbourhood <- as.factor(airbnb_data$Neighbourhood)
airbnb_data$City <- as.factor(airbnb_data$City)
airbnb_data$Country <- as.factor(airbnb_data$Country)
```

Nos aseguramos que los cambios se han hecho bien:

```{r}

summary(airbnb_data[, c("Room.type", "Neighbourhood", "City", "Country")])

```

Con la información de arriba, comprobamos que efectivamente que `Room.type, Neighbourhood, City y Country` son ahora variables catégoricas.

### `City y Country`

Podemos notar que en `City y Country`, hay algo que llama la atención. Se incluyen otras ciudades y países que no deberían estar.

```{r}
summary(airbnb_data[, c("City", "Country")])
```

Vemos que no todos los registros que pertenecen a España, son de Madrid.

Hacemos un filtrado en el que solo mantenemos las filas donde el valor de la columna `City es Madrid.`

```{r}
library(dplyr)

# Filtrar el dataset para mantener solo las filas donde la ciudad es Madrid
airbnb_data <- airbnb_data |> filter(City == "Madrid")


```

Una vez hecho el filtro, verificamos que en `City`, no aparezca nada que no sea `Madrid`.

```{r}
# Verificar que sólo quedan entradas de Madrid en el dataset original
summary(airbnb_data[, c("City")])
```

La información de arriba, es lo que esperabamos, solo quedan los registros de Madrid.

### `Availibility`

Transformamos la columna **`Availibility`** en una variable categórica, definiendo rangos específicos que representan distintos niveles de disponibilidad.\
\
Esta categorización nos permite analizar y visualizar la información de forma más eficiente.

```{r}

# Rangos de disponibilidad y sus etiquetas
breaks <- c(-1, 0, 30, 60, 90, 180, 365)
labels <- c("No disponible", "Hasta 30 días", "31 a 60 días", "61 a 90 días", "91 a 180 días", "181 a 365 días")

# Categorizar 'Availability' usando cut()
airbnb_data$Availability_Cat <- cut(airbnb_data$Availibility, breaks = breaks, labels = labels, include.lowest = TRUE)


airbnb_data$Availability_Cat<- as.factor(airbnb_data$Availability_Cat)

```

Realizamos una revisión de la nueva columna para asegurarnos de que la asignación de categorías se hizo correctamente

```{r}
summary(airbnb_data$Availability_Cat)

```

### `Coordinates`

La columna **`Coordinates`** contiene pares de valores separados por comas que representan la latitud y longitud geográfica

```{r}
head(airbnb_data$Coordinates)
```

Dividimos **`Coordinates`** en dos columnas, Latitude y Longitude que representan las coordenadas geográficas.

```{r}
# Asegurándonos de que la columna Coordinates está en formato de string
airbnb_data$Coordinates <- as.character(airbnb_data$Coordinates)

# Separar la columna Coordinates en dos nuevas columnas: Latitude y Longitude
airbnb_data<- airbnb_data |>
  separate(Coordinates, into = c("Latitude", "Longitude"), sep = ",", convert = TRUE)


```

Nos aseguramos de que el cambio se ha hecho efectivo:

```{r}
str(airbnb_data[, c("Latitude", "Longitude")])
```

Como podemos comprobar, ahora la columna **`Coordinates`** se ha convertido en 2: `Latitude y Longitude`

### Location

Parece que la columna `Location` es la combinación de `Country, City, y Neighbourhood`. Vamos a probarlo:

```{r}

library(dplyr)

#Crea una nueva columna temporal llamada Combined que combina Country,City y Neighbourhood, separados por ",". 

airbnb_data <- airbnb_data |> mutate(Combined = paste(Country, City, Neighbourhood, sep = ", "))

#Compara la columna Location con la columna Combined para verificar si son iguales.

airbnb_data <- airbnb_data |> mutate(Location_Match = Location == Combined)


#Revisa cuántos y qué porcentaje de las filas tienen coincidencia exacta entre Location y la columna combinada.

table(airbnb_data$Location_Match) #Cuenta solo lo que es TRUE

```

Comparamos la columna `Location` con la combinación de `Country, City, y Neighbourhood`.

Podemos ver que son iguales. `Location` redundante por lo que se puede eliminar:

```{r}
#Eliminar Location
airbnb_data <- select(airbnb_data, -Location)
```

## `Estudio de los valores nulos y ceros.`

Creamos un dataframe solo con las columnas que tienen nulos o ceros

```{r}
# Dataframe con la contabilización de Nulos y Ceros
resultados <- data.frame(
  NA_Count = colSums(is.na(airbnb_data)),
  Zero_Count = colSums(airbnb_data == 0, na.rm = TRUE)
)

# Filtrar y mostrar solo las filas con NA o ceros
resultados_con_NA_o_ceros <- resultados[apply(resultados, 1, function(x) any(x > 0)), ]
print(resultados_con_NA_o_ceros)
```

#### `Number.of.reviews`, `Date.last.review` y `Number.of.reviews.per.month.`

Vemos que existe la misma cantidad de ceros en `Number.of.reviews`, que nulos en `Date.last.review` y `Number.of.reviews.per.month.`

¿Están relacionados estos tres valores?

Vamos a verlo:

```{r}

# Añadir una columna temporal para verificar la condición
airbnb_data <- airbnb_data |>
  mutate(
    check = Number.of.reviews == 0 & is.na(Date.last.review) & is.na(Number.of.reviews.per.month)
  )

# Sumar para comprobar la condición basada en Number.of.reviews
result <- airbnb_data |>
  filter(Number.of.reviews == 0) |>
  summarise(
    Total_Zero_Reviews = n(),
    Correct_Cases = sum(check)
  )

print(result)



```

Creamos una columna llamada `check`. Esta columna nos ayuda a ver si el número de reseñas es cero y, al mismo tiempo, si las fechas de la última reseña y el promedio de reseñas por mes están vacíos. Si se cumplen estas condiciones, la columna indica **True**; si no, muestra **False**.

Comparamos la cuenta de los registros donde el número de reseñas es cero, contra la columna `check.`

Este paso nos permite comprobar si nuestra teoría sobre la relación entre estas variables se sostiene.

**Tiene sentido, ya que si un alojamiento no ha recibido reseñas, no podría tener una fecha de última reseña ni un promedio de reseñas mensuales**.

##### `Categorización de Number.of.reviews` y `Number.of.reviews.per.month`

Vamos a categorizar `Number.of.reviews` y `Number.of.reviews.per.month`para un mejor análisis

Empezamos colocando ceros en los valores nulos de `Number.of.reviews.per.month, para`asegurarmos podamos operar sobre esta columna, más adelante.

```{r}
sum(is.na(airbnb_data$Number.of.reviews.per.month))
```

Tenemos `5400 registros vacíos` de `Number.of.reviews.per.month.`

Sustituimos NA por el valor cero.

```{r}
# Sustituir directamente los NA por 0 en la columna específica
airbnb_data$Number.of.reviews.per.month[is.na(airbnb_data$Number.of.reviews.per.month)] <- 0
```

```{r}

#Calculo el total de filas con NA 
paste("Total suma de filas NA:", sum(is.na(airbnb_data$Number.of.reviews.per.month)))

#Calculo el total de filas con ceros 
paste("Total suma de filas con ceros:", sum(airbnb_data$Number.of.reviews.per.month == 0))


```

Como podemos comprobar, el cambio se ha hecho correctamente. Los `5400 registros vacíos` de `Number.of.reviews.per.month` ahora contienen ceros.

\
Ahora categorizamos la variable:

```{r}
library(dplyr)

airbnb_data <- airbnb_data |> 
  mutate(
    Review_category = factor(
      cut(
        Number.of.reviews.per.month,
        breaks = c(-Inf, 0, 1, 5, 10, Inf),  # Incluyendo  la categoría de "sin reseñas" en los breaks
        labels = c('sin reseñas', '0-1/mes', '1-5/mes', '5-10/mes', '+10/mes'),
        include.lowest = TRUE,
        right = TRUE
      )
    )
  )


summary(airbnb_data$Review_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-1/mes, incluye los valores desde 0.01 reviews.per.month a 1 (incluido)
#El intervalo 1-5/mes, incluye los valores desde 1,01 reviews.per.month a 5 (incluido) y asi sucesivamente 
```

Si el valor es cero, lo categorizamos como "sin reseñas". Luego, los valores se dividen en los siguientes rangos: 0-1/mes, 1-5/mes, 5-10/mes y +10/mes. Finalmente, creamos una nueva variable llamada **`Review_category`** que contiene estas categorías.

Ahora categorizamos la variable `Number.of.reviews`:

```{r}
library(dplyr)

airbnb_data <- airbnb_data |> 
  mutate(
    Review_Count_Category = factor(
      cut(
        Number.of.reviews,
        breaks = c(-Inf, 0, 1, 10, 50, 100, 500, Inf),  # Incluyendo la condición de 0 reseñas directamente en los breaks
        labels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas'),
        include.lowest = TRUE,
        right = TRUE
      ),
      levels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas')
    )
  )

# Puedes verificar el resultado con:
summary(airbnb_data$Review_Count_Category)


#NOTA: 
#El intervalo sin reseñas, incluye todos los ceros
#El intervalo1 reseña, incluye solos los valor 1 
#El intervalo '2-10 reseñas', incluye los valores desde 2 a 10 (incluido)
#El intervalo '11-50 reseñas', incluye los valores desde 11 a 50 (incluido) y asi sucesivamente 


```

Si hay cero reseñas, se etiqueta como "sin reseñas". De lo contrario, se divide en varios rangos, como 1 reseña, 2-10 reseñas, 11-50 reseñas, etc. Luego, se crea una nueva variable llamada **`Review_Count_Category`** con estas categorías.

#### `Date.last.review`

Es fundamental considerar la actualidad de la información y su influencia en los análisis y decisiones basadas en estos datos. Vamos a calcular la cantidad de días transcurridos desde el último scraping hasta la fecha de extracción de los datos.

```{r}

# Calcular el número de días desde la última revisión hasta la fecha de extracción
#Asumimos que la fecha del ultimo scrapping fue

date_scraped <- as.Date("2020-08-07")

airbnb_data$time_since_last_review <- as.numeric(difftime(date_scraped, airbnb_data$Date.last.review, units = "days"))

```

Se calcula el tiempo transcurrido en días desde la fecha de extracción de datos, representada por "2020-08-07", hasta la fecha de la última reseña. La diferencia se almacena en una nueva columna llamada **`time_since_last_review`**

Ahora veamos la distribución de los datos en **`time_since_last_review`**

```{r}
# Histograma del tiempo transcurrido desde la última reseña
ggplot(airbnb_data, aes(x = time_since_last_review)) +
  geom_histogram(bins = 30, fill = "#69b3a2", color = "#e9ecef") + # Colores personalizados para las barras
  theme_minimal() +
  theme(
    text = element_text(family = "Helvetica", size = 12), # Cambia la fuente y el tamaño del texto
    plot.title = element_text(face = "bold", hjust = 0.5), # Negrita y centrado para el título
    plot.subtitle = element_text(face = "italic", hjust = 0.5), # Subtítulo en cursiva y centrado
    axis.title = element_text(face = "bold", size = 13) # Títulos de los ejes en negrita y tamaño aumentado
  ) +
  labs(
    title = "Distribución de días desde la última reseña",
    subtitle = "Visualización de la frecuencia de días transcurridos",
    x = "Días desde la última reseña", y = "Frecuencia"
  )
```

Para poder realizar un mejor análisis de los datos, vamos a categorizar las nueva columna: **`time_since_last_review`**

```{r}
library(dplyr)

airbnb_data <- airbnb_data |>
  mutate(
    Time_category = factor(
      if_else(
        is.na(time_since_last_review),
        'sin reseñas',  # Asignar directamente 'sin reseñas' si el valor es NA
        cut(  # Usar cut solo en valores no-NA
          time_since_last_review,
          breaks = c(0, 60, 182, 365, Inf),  # Definiendo los rangos
          labels = c('hasta 8 semanas', '8 semanas - 6 meses', '6-12 meses', '1+ año'),
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', 'hasta 8 semanas', '8 semanas - 6 meses', '6-12 meses', '1+ año')
    )
  )

summary(airbnb_data$Time_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo hasta 8 semanas, incluye los valores hasta e 60 (incluida)
#El intervalo 8 semanas - 6 meses, incluye los valores desde 61 a 182 (incluido)  y asi sucesivamente 

```

#### **`Availibility`**

```{r}
#Calculo el total de filas con ceros 
paste("Total suma de filas con ceros:", sum(airbnb_data$Availibility == 0))
```

Los ceros de **`Availibility`**, se han tratado en la columna **`Availibility_Cat`** como alojamientos "No disponibles"

```{r}
summary(airbnb_data$Availability_Cat)

```

Vemos que el recuento de "No disponible" en **`Availibility_Cat`**, coincide con el recuento de ceros en **`Availibility.`**

## `Resumen cambios en las variables.`

Resumen condensado y ajustado de las transformaciones aplicadas:

#### `1. Date.last.review y Updated.Date`

-   Convertidas a formato de fecha (`%Y-%m-%d`).
-   Calculada la diferencia en días desde la fecha del último scraping (`2020-08-07`) hasta `Date.last.review`. El resultado se almacena en `Time_category` y se categoriza en:
    -   "sin reseñas" (casos donde la fecha es nula)
    -   "hasta 8 semanas"
    -   "8 semanas - 6 meses"
    -   "6-12 meses"
    -   "1+ año"

#### `2. Room.type, Neighbourhood, City, Country`

-   Transformadas en variables categóricas (factores) para facilitar análisis por segmentos.

#### `3. Availability`

-   Categorizada en la columna `Availibility_Cat`desde 'No disponible' hasta '181 a 365 días' en rangos que representan distintos niveles de disponibilidad:
    -   "No disponible" (para alojamientos con cero días disponibles)
    -   "Menos de 30 días"
    -   "31 a 60 días"
    -   "61 a 90 días"
    -   "91 a 180 días"
    -   "181 a 365 días"

#### `4. City`

-   Filtrados los datos para incluir solo entradas de Madrid.

#### `5. Coordinates`

-   Separada en dos columnas numéricas: `Latitude` y `Longitude`.

#### `6. Location`

-   Eliminada tras confirmar redundancia con `Country`, `City`, y `Neighbourhood`.

#### `7. Number.of.reviews & Number.of.reviews.per.month`

-   Análisis de valores nulos y ceros; categorizados para facilitar análisis:
    -   **Review_Count_Category** (basado en `Number.of.reviews`):
        -   "sin reseñas"
        -   "1 reseña"
        -   "2-10 reseñas"
        -   "11-50 reseñas"
        -   "51-100 reseñas"
        -   "101-500 reseñas"
        -   "500+ reseñas"
    -   **Review_category** (basado en `Number.of.reviews.per.month`):
        -   "sin reseñas" (incluye registros nulos y ceros)
        -   "0-1/mes"
        -   "1-5/mes"
        -   "5-10/mes"
        -   "10-20/mes"
        -   "20+ mes"

Este resumen aclara y especifica las transformaciones y categorizaciones realizadas en cada variable, alineándolas con las operaciones y el análisis llevado a cabo en tu código R.

### Gráficos

```{r}
# Instalar paquetes si no están instalados
if (!require("readxl")) install.packages("readxl")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("ggmap")) install.packages("ggmap")
if (!require("dplyr")) install.packages("dplyr")

# Cargar paquetes
library(readxl)
library(ggplot2)
library(corrplot)
library(ggmap)
library(dplyr)

```

#### **Gráficos por variables**

##### Variables Categóricas

```{r}
#Histogramas

# Grafico para barrio  

ggplot(airbnb_data, aes(y = Neighbourhood)) +
  geom_bar() +
  theme(axis.text.y = element_text(size = 5)) +
  labs(title = "Distribución por Vecindario", x = "Frecuencia", y = "Barrio")

# Gráfico para Room.type
ggplot(airbnb_data, aes(x = Room.type)) +
  geom_bar(fill = "coral") +
  labs(title = "Distribución por Tipo de Habitación", x = "Tipo de Habitación", y = "Frecuencia")

# Gráfico para Availability_Cat
ggplot(airbnb_data, aes(x = Availability_Cat)) +
  geom_bar(fill = "purple") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución por Categoría de Disponibilidad", x = "Categoría de Disponibilidad", y = "Frecuencia")

# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Time_category)) +
  geom_bar(fill = "yellow") +
  labs(title = "Distribución de Time_category (Resta entre Scrapping date y Date.last.review)", x = "Time_category", y = "Frecuencia")

# Gráfico para Review_category
ggplot(airbnb_data, aes(x = Review_category)) +
  geom_bar(fill = "green") +
  labs(title = "Distribución de Review_category (Categorizacion de Number.of.reviews.per.month)", x = "Review_category", y = "Frecuencia")

# Gráfico para Review_Count_Category
ggplot(airbnb_data, aes(x = Review_Count_Category)) +
  geom_bar(fill = "blue") +
  labs(title = "Distribución de Review_Count_Category (Categorizacion de Number.of.reviews)", x = "Review_Count_Category", y = "Frecuencia")


```

##### Variables Numéricas

```{r}
# Cargar la librería necesaria
library(ggplot2)

# Boxplot para Room.Price
ggplot(airbnb_data, aes(y = Room.Price)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = "Distribución del Precio de la Habitación",
       y = "Precio (€)",
       x = "") +
  theme_minimal()

# Boxplot para Minimum.nights
ggplot(airbnb_data, aes(y = Minimum.nights)) +
  geom_boxplot(fill = "lightgreen", color = "darkgreen") +
  labs(title = "Distribución del Número Mínimo de Noches Requeridas",
       y = "Número Mínimo de Noches",
       x = "") +
  theme_minimal()

# Boxplot para Rooms.rent.by.the.host
ggplot(airbnb_data, aes(y = Rooms.rent.by.the.host)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Habitaciones alquiladas por el host",
       y = "Habitaciones alquiladas por el host",
       x = "") +
  theme_minimal()

```

```{r}

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Room.Price)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Precios", x = "Precio", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Minimum.nights)) +
  geom_density(fill = "green", alpha = 0.5) +
  labs(title = "Distribución de Minimum.nights", x = "Minimum.nights", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Rooms.rent.by.the.host)) +
  geom_density(fill = "yellow", alpha = 0.5) +
  labs(title = "Distribución de Rooms.rent.by.the.host", x = "Rooms.rent.by.the.host", y = "Densidad")

```

#### **Otros gráficos**

#### **Histograma del vecindario en términos de distritos**

```{r}

library(ggplot2)

ggplot(airbnb_data, aes(x = Neighbourhood)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Histograma del Vecindario en Términos de Distritos", 
       x = "Distrito", 
       y = "Frecuencia") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Primero se establece el dataframe airbnb_data como el conjunto de datos para el gráfico y mapea la variable Neighbourhood en el eje x del gráfico. Después se añade un gráfico de barras al gráfico base. Elegí  el color de relleno de las barras como "skyblue" y el color de borde como "black".

labs(title = "Histograma del Vecindario en Términos de Distritos", x = "Distrito", y = "Frecuencia"): Esta función establece el título del gráfico como "Histograma del Vecindario en Términos de Distritos" y etiqueta los ejes x e y como "Distrito" y "Frecuencia", respectivamente.

\
**Distribución de precio vs número de reseñas**\

Configura el dataframe airbnb_data para el gráfico y mapea el precio de la habitación en el eje x y el número de reseñas en el eje y.Agregamos puntos al gráfico base para mostrar la distribución de los datos. Y establece el título del gráfico como "Distribución de Precio vs Número de Reseñas".

```{r}
ggplot(airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) +

geom_point(color = "blue") +

labs(title = "Distribución de Precio vs Número de Reseñas", x = "Precio de la Habitación (€)", y = "Número de Reseñas")


```

\
**Precio promedio vs tipo de habitación**\

```{r}
ggplot(airbnb_data, aes(x = Room.type, y = Room.Price)) +

geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "darkgreen") +

labs(title = "Precio Promedio vs Tipo de Habitación", x = "Tipo de Habitación", y = "Precio Promedio (€)")


```

\
Configura el dataframe airbnb_data para el gráfico y mapea el tipo de habitación en el eje x y el precio de la habitación en el eje y. Luego agrega un gráfico de barras al gráfico base. Calcula la media del precio de la habitación para cada tipo de habitación y usa "skyblue" como color de relleno. Ystablece el título del gráfico como "Precio Promedio vs Tipo de Habitación" y etiqueta los ejes x e y como "Tipo de Habitación" y "Precio Promedio", respectivamente.

\

#### Tipo de propiedad y áreas (distritos) 

```{r}
# Crear un gráfico de barras apiladas 

ggplot(data = airbnb_data, aes(x = Neighbourhood, fill = `Room.type`)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Cantidad") + ggtitle("Distribución de tipos de propiedad por distritos en Madrid")
```

El gráfico muestra la distribución de los diferentes tipos de propiedades en cada distrito de Madrid. Cada barra representa un distrito y los segmentos de cada barra están coloreados para representar los diferentes tipos de propiedad. Los segmentos de cada barra se apilan unos sobre otros.

#### Distribución de precios vs distrito 

```{r}
ggplot(data = airbnb_data, aes(x = Neighbourhood, y = Room.Price)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Precio") + ggtitle("Distribución de precios por distrito en Madrid")
```

\
Este gráfico representa la distribución de los precios para cada distrito. Cada caja muestra la distribución de los precios en un distrito específico, donde la línea en el centro de la caja representa la mediana de los precios. Los puntos individuales fuera de los bigotes representan valores atípicos potenciales.

#### Tendencia mediana y puntuación de reseñas 

```{r}
ggplot(data = airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) + geom_point() + geom_smooth(method = "lm", se = FALSE, color = "red") + labs(x = "Precio", y = "Puntuación  de reseñas") + ggtitle("Tendencia de la mediana de precios por puntuación de reseñas por distrito en Madrid")
```

\
Este gráfico muestra la relación entre el precio y el puntuación de las reseñas recibidas. Cada punto en el gráfico representa un listado individual, donde la posición horizontal del punto indica el precio y la posición vertical indica el número de reseñas.

El gráfico incluye una línea de tendencia (en rojo) ajustada mediante un modelo de regresión lineal. Esta línea de tendencia representa la tendencia general entre el precio y el número de reseñas: si la línea de tendencia tiene una pendiente positiva, indica una relación positiva entre el precio y el número de reseñas, mientras que una pendiente negativa indica una relación negativa.

#### Gráfico de Distribución en Madrid

Las columnas `Latitude` y `Longitude` están disponibles, podemos crear un mapa de puntos en Madrid:

```{r}
# Instalar y cargar los paquetes necesarios
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)
if (!require("leaflet.extras")) install.packages("leaflet.extras")
library(leaflet.extras)


# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir la capa de mapa de calor
madrid_map <- madrid_map |>
  addHeatmap(
    lng = ~Longitude, lat = ~Latitude, intensity = ~1,
    blur = 20, max = 0.05, radius = 15
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map

```

```{r}
# Cargar el paquete dplyr para manipulación de datos
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)

# Definir una función para determinar el color basado en el precio
get_color <- function(price) {
  if (price < 50) {
    "#00FF00"  # Verde para precios bajos
  } else if (price < 100) {
    "#FFFF00"  # Amarillo para precios medios
  } else {
    "#FF0000"  # Rojo para precios altos
  }
}

# Añadir una nueva columna al dataset con los colores calculados
airbnb_data <- airbnb_data %>%
  mutate(Color = sapply(Room.Price, get_color))

# Crear el mapa
library(leaflet)

madrid_map <- leaflet(data = airbnb_data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    ~Longitude, ~Latitude,
    radius = 5,
    color = ~Color,
    fillOpacity = 0.5,
    stroke = FALSE,  # No dibujar bordes alrededor de los círculos
    group = "Airbnb Locations"
  ) %>%
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map


```

#### Mapa de Calor de Correlación

Para el mapa de calor de correlación, seleccionamos las columnas numéricas relevantes.

```{r}

# Instalar paquetes si no están instalados
if (!require("dplyr")) install.packages("dplyr")
if (!require("corrplot")) install.packages("corrplot")

library(dplyr)
library(corrplot)

# Seleccionando columnas relevantes para la correlación
cor_data <- airbnb_data |>
  select(Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host) |>
  na.omit()  # Eliminando filas con valores NA para evitar errores

# Calculando la matriz de correlación
cor_matrix <- cor(cor_data)

# Generando el mapa de calor
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45, addrect = 2, 
         title = "Mapa de Calor de Correlación para AirBnB en Madrid",
         mar = c(0, 0, 2, 0))  # Ajusta el margen superior para dar más espacio al título


```

```{r}
library("ggplot2")
library("GGally")

airbnb_data2 <- select(airbnb_data, Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host)

ggpairs(airbnb_data2)
```

```{r}

if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "dataset_airbnb_procesado.xlsx")

```
