---
title: "cuaderno"
format: html
editor: visual
---

# Análisis Exploratorio de Dataset de Airbnb (Madrid-España)

Este análisis explora un conjunto de datos de Airbnb, específicamente centrado en las listas de alojamientos disponibles en Madrid, España. Los datos han sido descargados desde el portal público OpenDataSoft, una plataforma que facilita el acceso a diversos datasets abiertos para análisis y aplicaciones de datos. Puedes acceder directamente al dataset utilizado a través del siguiente enlace: [Airbnb Listings en OpenDataSoft](https://public.opendatasoft.com/explore/dataset/air-bnb-listings/table/?disjunctive.neighbourhood&disjunctive.column_10&disjunctive.city&q=Madrid&location=7,40.5931,-4.422&basemap=jawg.light).

En primer lugar, leemos el dataset, se especifica que el separador de campos es un punto y coma.

```{r}
library(tidyverse)

# Leer el archivo CSV
airbnb_data_raw <- read.csv("../data/raw/air-bnb-listings.csv", sep = ';')

```

Mostramos las primeras filas del dataset. Esto nos permite comprobar que los datos se han cargado correctamente.

```{r}
# Ver las primeras filas de los datos
head(airbnb_data_raw)

```

Calculamos y mostramos las dimensiones originales del dataset, obteniendo el número de filas y columnas.

```{r}
dimension_original <- dim(airbnb_data_raw)

paste('El numero de filas que tiene el dataframe airbnb_data es:', dimension_original[1])
paste('El numero de columnas que tiene el dataframe airbnb_data es:', dimension_original[2])
```

El dataset original, tiene `17 variables(columnas)` y `21278 observaciones(filas).`

Examinamos que tipo de variables tenemos.

```{r}
str(airbnb_data_raw)
```

Vemos que tenemos variables categóricas como `Room.type, Neighbourhood, City y Country` que no se están tomando como tal, sino como `character`. Lo mismo sucede con las fechas.

Para tener más visibilidad del tipo y clase de dato que tiene cada columna, creamos un DataFrame que muestre la informacion sobre la clase y el tipo de datos de cada variable.

```{r}

# Función para obtener las clases y tipos de las columnas de un dataframe
obtener_clase_tipo <- function(data) {
  # Crear un vector con los nombres de las columnas
  column_names <- colnames(data)

  # Obtener la clase y el tipo de cada columna utilizando sapply
  column_classes <- sapply(data, class)
  column_types <- sapply(data, typeof)

  # Crear el dataframe con la información recopilada de Clase y Tipo
  clase_tipo <- data.frame(
    Class = column_classes,     # Clase de cada columna
    Type = column_types         # Tipo de cada columna
  )
  
  # Devolver el dataframe
  return(clase_tipo)
}

# Usar la función con el dataframe airbnb_data
resultado_clase_tipo <- obtener_clase_tipo(airbnb_data_raw)
print(resultado_clase_tipo)



```

Con esta información, vamos a proceder a hacer las conversiones necesarias:

## `Conversión de variables`

Para asegurar la integridad del dataframe original mientras realizamos cambios, primero crearemos una copia del mismo. Todas las modificaciones y análisis se realizarán en esta copia, denominada **`airbnb_data`**.

```{r}
airbnb_data <- data.frame(airbnb_data_raw)

```

Como hemos visto arriba, hay columnas que deberían ser de diferente clase.

```{r}
str(airbnb_data[, c("Date.last.review", "Updated.Date", "Room.type", "Neighbourhood", "City", "Country")])
```

**`Data.last.review y Update.Date`.**

**Deberían ser fecha:** Ya que ambas variables permiten cálculos como la diferencia de días entre eventos, agrupación por períodos de tiempo (por ejemplo, mes, año), y correlacionar eventos o cambios con fechas específicas, lo cual sería difícil si estas variables fueran tratadas de otra manera (como character por ejemplo).

**`Room.type, Neighbourhood, City y Country`**

**Deberían ser categóricas:** Ya que agrupan los datos usando etiquetas textuales y facilitan análisis por segmentos. Además, no representan cantidades ni establecen un orden, características típicas de las variables categóricas.

### `Data.last.review y Update.Date`

Convertimos ambas columnas a fechas:

```{r}

# Convertir la columna Date.last.review a tipo fecha
airbnb_data$Date.last.review <- as.Date(airbnb_data$Date.last.review, format = "%Y-%m-%d")

# Convertir la columna Updated.Date a tipo fecha
airbnb_data$Updated.Date <- as.Date(airbnb_data$Updated.Date, format = "%Y-%m-%d")

```

Comprobamos que se ha realizado con éxito el cambio:

```{r}
str(airbnb_data[, c("Date.last.review", "Updated.Date")])

```

Como podemos comprobar arriba, el cambio se hizo correctamente. `Data.last.review y Update.Date` son ahora fechas.

### `Room.type, Neighbourhood, City y Country`

Convertimos estas variables en categóricas.

```{r}

# Convertir columnas a factores (categóricas)
airbnb_data$Room.type <- as.factor(airbnb_data$Room.type)
airbnb_data$Neighbourhood <- as.factor(airbnb_data$Neighbourhood)
airbnb_data$City <- as.factor(airbnb_data$City)
airbnb_data$Country <- as.factor(airbnb_data$Country)
```

Nos aseguramos que los cambios se han hecho bien:

```{r}

summary(airbnb_data[, c("Room.type", "Neighbourhood", "City", "Country")])

```

Con la información de arriba, comprobamos que efectivamente que `Room.type, Neighbourhood, City y Country` son ahora variables catégoricas.

### `City y Country`

Podemos notar que en `City y Country`, hay algo que llama la atención. Se incluyen otras ciudades y países que no deberían estar.

```{r}
summary(airbnb_data[, c("City", "Country")])
```

Vemos que no todos los registros que pertenecen a España, son de Madrid.

Hacemos un filtrado en el que solo mantenemos las filas donde el valor de la columna `City es Madrid.`

```{r}
library(dplyr)

# Filtrar el dataset para mantener solo las filas donde la ciudad es Madrid
airbnb_data <- airbnb_data |> filter(City == "Madrid")


```

Una vez hecho el filtro, verificamos que en `City`, no aparezca nada que no sea `Madrid`.

```{r}
# Verificar que sólo quedan entradas de Madrid en el dataset original
summary(airbnb_data[, c("City", "Country")])
```

La información de arriba, es lo que esperabamos, solo quedan los registros de Madrid.\
Sin embargo siguen apareciendo otros niveles tanto en `City y Country`. Ya no los necesitamos, así los vamos a eliminar.

```{r}
airbnb_data$City <- droplevels(airbnb_data$City)
airbnb_data$Country <- droplevels(airbnb_data$Country)

#Verificamos que solo queden los niveles deseados en City y Country
summary(airbnb_data[, c("City", "Country")])
```

### `Availibility`

Transformamos la columna **`Availibility`** en una variable categórica, definiendo rangos específicos que representan distintos niveles de disponibilidad.\
\
Esta categorización nos permite analizar y visualizar la información de forma más eficiente.

```{r}

# Rangos de disponibilidad y sus etiquetas
breaks <- c(-1, 0, 30, 60, 90, 180, 365)
labels <- c("No disponible", "Hasta 30 días", "31 a 60 días", "61 a 90 días", "91 a 180 días", "181 a 365 días")

# Categorizar 'Availability' usando cut()
airbnb_data$Availability_Cat <- cut(airbnb_data$Availibility, breaks = breaks, labels = labels, include.lowest = TRUE)


airbnb_data$Availability_Cat<- as.factor(airbnb_data$Availability_Cat)

```

Realizamos una revisión de la nueva columna para asegurarnos de que la asignación de categorías se hizo correctamente

```{r}
summary(airbnb_data$Availability_Cat)

```

### `Coordinates`

La columna **`Coordinates`** contiene pares de valores separados por comas que representan la latitud y longitud geográfica

```{r}
head(airbnb_data$Coordinates)
```

Dividimos **`Coordinates`** en dos columnas, Latitude y Longitude que representan las coordenadas geográficas.

```{r}
# Asegurándonos de que la columna Coordinates está en formato de string
airbnb_data$Coordinates <- as.character(airbnb_data$Coordinates)

# Separar la columna Coordinates en dos nuevas columnas: Latitude y Longitude
airbnb_data<- airbnb_data |>
  separate(Coordinates, into = c("Latitude", "Longitude"), sep = ",", convert = TRUE)


```

Nos aseguramos de que el cambio se ha hecho efectivo:

```{r}
str(airbnb_data[, c("Latitude", "Longitude")])
```

Como podemos comprobar, ahora la columna **`Coordinates`** se ha convertido en 2: `Latitude y Longitude`

### Location

Parece que la columna `Location` es la combinación de `Country, City, y Neighbourhood`. Vamos a probarlo:

```{r}

library(dplyr)

#Crea una nueva columna temporal llamada Combined que combina Country,City y Neighbourhood, separados por ",". 

airbnb_data <- airbnb_data |> mutate(Combined = paste(Country, City, Neighbourhood, sep = ", "))

#Compara la columna Location con la columna Combined para verificar si son iguales.

airbnb_data <- airbnb_data |> mutate(Location_Match = Location == Combined)


#Revisa cuántos y qué porcentaje de las filas tienen coincidencia exacta entre Location y la columna combinada.

table(airbnb_data$Location_Match) #Cuenta solo lo que es TRUE

```

Comparamos la columna `Location` con la combinación de `Country, City, y Neighbourhood`.

Podemos ver que son iguales. `Location` redundante por lo que se puede eliminar:

```{r}
#Eliminar Location
airbnb_data <- select(airbnb_data, -Location)
```

## `Estudio de los valores nulos y ceros.`

Creamos un dataframe solo con las columnas que tienen nulos o ceros

```{r}
# Dataframe con la contabilización de Nulos y Ceros
resultados <- data.frame(
  NA_Count = colSums(is.na(airbnb_data)),
  Zero_Count = colSums(airbnb_data == 0, na.rm = TRUE)
)

# Filtrar y mostrar solo las filas con NA o ceros
resultados_con_NA_o_ceros <- resultados[apply(resultados, 1, function(x) any(x > 0)), ]
print(resultados_con_NA_o_ceros)
```

#### `Number.of.reviews`, `Date.last.review` y `Number.of.reviews.per.month.`

Vemos que existe la misma cantidad de ceros en `Number.of.reviews`, que nulos en `Date.last.review` y `Number.of.reviews.per.month.`

¿Están relacionados estos tres valores?

Vamos a verlo:

```{r}

# Añadir una columna temporal para verificar la condición
airbnb_data <- airbnb_data |>
  mutate(
    check = Number.of.reviews == 0 & is.na(Date.last.review) & is.na(Number.of.reviews.per.month)
  )

# Sumar para comprobar la condición basada en Number.of.reviews
result <- airbnb_data |>
  filter(Number.of.reviews == 0) |>
  summarise(
    Total_Zero_Reviews = n(),
    Correct_Cases = sum(check)
  )

print(result)



```

Creamos una columna llamada `check`. Esta columna nos ayuda a ver si el número de reseñas es cero y, al mismo tiempo, si las fechas de la última reseña y el promedio de reseñas por mes están vacíos. Si se cumplen estas condiciones, la columna indica **True**; si no, muestra **False**.

Comparamos la cuenta de los registros donde el número de reseñas es cero, contra la columna `check.`

Este paso nos permite comprobar si nuestra teoría sobre la relación entre estas variables se sostiene.

**Tiene sentido, ya que si un alojamiento no ha recibido reseñas, no podría tener una fecha de última reseña ni un promedio de reseñas mensuales**.

##### `Categorización de Number.of.reviews` y `Number.of.reviews.per.month`

Vamos a categorizar `Number.of.reviews` y `Number.of.reviews.per.month`para un mejor análisis

Empezamos colocando ceros en los valores nulos de `Number.of.reviews.per.month, para`asegurarmos podamos operar sobre esta columna, más adelante.

```{r}
sum(is.na(airbnb_data$Number.of.reviews.per.month))
```

Tenemos `5400 registros vacíos` de `Number.of.reviews.per.month.`

Sustituimos NA por el valor cero.

```{r}
# Sustituir directamente los NA por 0 en la columna específica
airbnb_data$Number.of.reviews.per.month[is.na(airbnb_data$Number.of.reviews.per.month)] <- 0
```

```{r}

#Calculo el total de filas con NA 
paste("Total suma de filas NA:", sum(is.na(airbnb_data$Number.of.reviews.per.month)))

#Calculo el total de filas con ceros 
paste("Total suma de filas con ceros:", sum(airbnb_data$Number.of.reviews.per.month == 0))


```

Como podemos comprobar, el cambio se ha hecho correctamente. Los `5400 registros vacíos` de `Number.of.reviews.per.month` ahora contienen ceros.

\
Ahora categorizamos la variable:

```{r}
library(dplyr)

airbnb_data <- airbnb_data |> 
  mutate(
    Review_category = factor(
      cut(
        Number.of.reviews.per.month,
        breaks = c(-Inf, 0, 1, 5, Inf),  # Incluyendo  la categoría de "sin reseñas" en los breaks
        labels = c('sin reseñas', '0-1/mes', '1-5/mes', '+5/mes'),
        include.lowest = TRUE,
        right = TRUE
      )
    )
  )


summary(airbnb_data$Review_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo 0-1/mes, incluye los valores desde 0.01 reviews.per.month a 1 (incluido)
#El intervalo 1-5/mes, incluye los valores desde 1,01 reviews.per.month a 5 (incluido) y asi sucesivamente 
```

Si el valor es cero, lo categorizamos como "sin reseñas". Luego, los valores se dividen en los siguientes rangos: 0-1/mes, 1-5/mes, 5-10/mes y +10/mes. Finalmente, creamos una nueva variable llamada **`Review_category`** que contiene estas categorías.

Ahora categorizamos la variable `Number.of.reviews`:

```{r}
library(dplyr)

airbnb_data <- airbnb_data |> 
  mutate(
    Review_Count_Category = factor(
      cut(
        Number.of.reviews,
        breaks = c(-Inf, 0, 1, 10, 50, 100, 500, Inf),  # Incluyendo la condición de 0 reseñas directamente en los breaks
        labels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas'),
        include.lowest = TRUE,
        right = TRUE
      ),
      levels = c('sin reseñas', '1 reseña', '2-10 reseñas', '11-50 reseñas', '51-100 reseñas', '101-500 reseñas', '500+ reseñas')
    )
  )

# Puedes verificar el resultado con:
summary(airbnb_data$Review_Count_Category)


#NOTA: 
#El intervalo sin reseñas, incluye todos los ceros
#El intervalo1 reseña, incluye solos los valor 1 
#El intervalo '2-10 reseñas', incluye los valores desde 2 a 10 (incluido)
#El intervalo '11-50 reseñas', incluye los valores desde 11 a 50 (incluido) y asi sucesivamente 


```

Si hay cero reseñas, se etiqueta como "sin reseñas". De lo contrario, se divide en varios rangos, como 1 reseña, 2-10 reseñas, 11-50 reseñas, etc. Luego, se crea una nueva variable llamada **`Review_Count_Category`** con estas categorías.

#### `Date.last.review`

Es fundamental considerar la actualidad de la información y su influencia en los análisis y decisiones basadas en estos datos. Vamos a calcular la cantidad de días transcurridos desde el último scraping hasta la fecha de extracción de los datos.

```{r}

# Calcular el número de días desde la última revisión hasta la fecha de extracción
#Asumimos que la fecha del ultimo scrapping fue

date_scraped <- as.Date("2020-08-07")

airbnb_data$time_since_last_review <- as.numeric(difftime(date_scraped, airbnb_data$Date.last.review, units = "days"))

```

Se calcula el tiempo transcurrido en días desde la fecha de extracción de datos, representada por "2020-08-07", hasta la fecha de la última reseña. La diferencia se almacena en una nueva columna llamada **`time_since_last_review`**

Ahora veamos la distribución de los datos en **`time_since_last_review`**

```{r}
# Histograma del tiempo transcurrido desde la última reseña
ggplot(airbnb_data, aes(x = time_since_last_review)) +
  geom_histogram(bins = 30, fill = "#69b3a2", color = "#e9ecef") + # Colores personalizados para las barras
  theme_minimal() +
  theme(
    text = element_text(family = "Helvetica", size = 12), # Cambia la fuente y el tamaño del texto
    plot.title = element_text(face = "bold", hjust = 0.5), # Negrita y centrado para el título
    plot.subtitle = element_text(face = "italic", hjust = 0.5), # Subtítulo en cursiva y centrado
    axis.title = element_text(face = "bold", size = 13) # Títulos de los ejes en negrita y tamaño aumentado
  ) +
  labs(
    title = "Distribución de días desde la última reseña",
    subtitle = "Visualización de la frecuencia de días transcurridos",
    x = "Días desde la última reseña", y = "Frecuencia"
  )
```

Para poder realizar un mejor análisis de los datos, vamos a categorizar las nueva columna: **`time_since_last_review`**

```{r}
library(dplyr)

airbnb_data <- airbnb_data |>
  mutate(
    Time_category = factor(
      if_else(
        is.na(time_since_last_review),
        'sin reseñas',  # Asignar directamente 'sin reseñas' si el valor es NA
        cut(  # Usar cut solo en valores no-NA
          time_since_last_review,
          breaks = c(0, 60, 182, 365, Inf),  # Definiendo los rangos
          labels = c('hasta 8 semanas', '8 semanas - 6 meses', '6-12 meses', '1+ año'),
          include.lowest = TRUE,
          right = TRUE
        )
      ),
      levels = c('sin reseñas', 'hasta 8 semanas', '8 semanas - 6 meses', '6-12 meses', '1+ año')
    )
  )

summary(airbnb_data$Time_category)

#NOTA: 
#El intervalo sin reseñas, incluye todos los nulos
#El intervalo hasta 8 semanas, incluye los valores hasta e 60 (incluida)
#El intervalo 8 semanas - 6 meses, incluye los valores desde 61 a 182 (incluido)  y asi sucesivamente 

```

#### **`Availibility`**

```{r}
#Calculo el total de filas con ceros 
paste("Total suma de filas con ceros:", sum(airbnb_data$Availibility == 0))
```

Los ceros de **`Availibility`**, se han tratado en la columna **`Availibility_Cat`** como alojamientos "No disponibles"

```{r}
summary(airbnb_data$Availability_Cat)

```

Vemos que el recuento de "No disponible" en **`Availibility_Cat`**, coincide con el recuento de ceros en **`Availibility.`**

## `Resumen cambios en las variables.`

Resumen condensado y ajustado de las transformaciones aplicadas:

#### `1. Date.last.review y Updated.Date`

-   Convertidas a formato de fecha (`%Y-%m-%d`).
-   Calculada la diferencia en días desde la fecha del último scraping (`2020-08-07`) hasta `Date.last.review`. El resultado se almacena en `Time_category` y se categoriza en:
    -   "sin reseñas" (casos donde la fecha es nula)
    -   "hasta 8 semanas"
    -   "8 semanas - 6 meses"
    -   "6-12 meses"
    -   "1+ año"

#### `2. Room.type, Neighbourhood, City, Country`

-   Transformadas en variables categóricas (factores) para facilitar análisis por segmentos.

#### `3. Availability`

-   Categorizada en la columna `Availibility_Cat`desde 'No disponible' hasta '181 a 365 días' en rangos que representan distintos niveles de disponibilidad:
    -   "No disponible" (para alojamientos con cero días disponibles)
    -   "Menos de 30 días"
    -   "31 a 60 días"
    -   "61 a 90 días"
    -   "91 a 180 días"
    -   "181 a 365 días"

#### `4. City`

-   Filtrados los datos para incluir solo entradas de Madrid.

#### `5. Coordinates`

-   Separada en dos columnas numéricas: `Latitude` y `Longitude`.

#### `6. Location`

-   Eliminada tras confirmar redundancia con `Country`, `City`, y `Neighbourhood`.

#### `7. Number.of.reviews & Number.of.reviews.per.month`

-   Análisis de valores nulos y ceros; categorizados para facilitar análisis:
    -   **Review_Count_Category** (basado en `Number.of.reviews`):
        -   "sin reseñas"
        -   "1 reseña"
        -   "2-10 reseñas"
        -   "11-50 reseñas"
        -   "51-100 reseñas"
        -   "101-500 reseñas"
        -   "500+ reseñas"
    -   **Review_category** (basado en `Number.of.reviews.per.month`):
        -   "sin reseñas" (incluye registros nulos y ceros)
        -   "0-1/mes"
        -   "1-5/mes"
        -   "5-10/mes"
        -   "10-20/mes"
        -   "20+ mes"

Este resumen aclara y especifica las transformaciones y categorizaciones realizadas en cada variable, alineándolas con las operaciones y el análisis llevado a cabo en tu código R.

```{r}
if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "dataset_airbnb_procesado1.xlsx")

```

## `Gráficos`

```{r}
# Instalar paquetes si no están instalados
if (!require("readxl")) install.packages("readxl")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("corrplot")) install.packages("corrplot")
if (!require("ggmap")) install.packages("ggmap")
if (!require("dplyr")) install.packages("dplyr")

# Cargar paquetes
library(readxl)
library(ggplot2)
library(corrplot)
library(ggmap)
library(dplyr)

```

### **`Gráficos por variables`**

#### `Variables Categóricas`

#### **`1. Neighbourhood`**

```{r}
#Histogramas

# Grafico para barrio  

library(ggplot2)
library(dplyr)

# Calcular la frecuencia de cada barrio
neighbourhood_freq <- airbnb_data |>
  count(Neighbourhood) |>
  arrange(desc(n)) |>
  top_n(10, n)  # Selecciona solo los top 10

# Graficar la distribución por barrio solo para los top 10
ggplot(neighbourhood_freq, aes(x = n, y = reorder(Neighbourhood, n))) +
  geom_bar(stat = "identity", fill = "steelblue") +  # Cambia el color de las barras
  theme_minimal() +
  theme(axis.text.y = element_text(size = 15),  # Aumenta el tamaño del texto del eje y
        plot.title = element_text(size = 22, face = "bold")) +  # Aumenta y pone en negrita el título
  labs(title = "Distribución por Barrio", x = "Frecuencia", y = "Barrio")





```

El gráfico representa la `frecuencia de listados de Airbnb en los top 10 barrios más populares`. Cada barra representa un barrio diferente, ordenados de mayor a menor frecuencia de arriba hacia abajo.

1.  **Barrios (Eje Y)**: Desde la parte superior, los barrios listados son Embajadores, Universidad, Palacio, Sol, Justicia, Cortes, Trafalgar, Palos de Moguer, Goya, y Puerta del Angel.

2.  **Frecuencia (Eje X)**: La escala del eje X va desde 0 hasta más de 2000, indicando el número de listados en cada barrio.

El barrio de `Embajadores` tiene la mayor cantidad de listados, seguido por `Universidad y Palacio`. Los barrios de `Goya y Puerta del Angel`, al final de la lista, tienen considerablemente menos listados comparados con los más altos en la gráfica.

#### **`2. Room.type`**

```{r}
# Gráfico para Room.type
ggplot(airbnb_data, aes(x = Room.type)) +
  geom_bar(fill = "coral") +
  labs(title = "Distribución por Tipo de Habitación", x = "Tipo de Habitación", y = "Frecuencia")
```

Las barras representan la frecuencia de cada tipo de habitación en el dataset.

-   **Tipos de Habitación (Eje X)**: Las categorías mostradas son "Entire home/apt" (casa o apartamento completo), "Hotel room" (habitación de hotel), "Private room" (habitación privada) y "Shared room" (habitación compartida).

-   **Frecuencia (Eje Y)**: El eje vertical muestra la cantidad de listados, con una escala que va de 0 a más de 10,000.

Observaciones clave del gráfico:

-   **Casa o apartamento completo** tiene la frecuencia más alta, indicando que es el tipo de alojamiento más comúnmente listado.

-   **Habitación privada** es el segundo tipo más común, aunque con una frecuencia significativamente menor en comparación con las casas o apartamentos completos.

-   **Habitación de hotel** y **habitación compartida** tienen las menores frecuencias, con la habitación compartida mostrando la menor popularidad entre los listados.

#### `3. Availability_Cat`

```{r}

# Gráfico para Availability_Cat
ggplot(airbnb_data, aes(x = Availability_Cat)) +
  geom_bar(fill = "purple") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Distribución por Categoría de Disponibilidad", x = "Categoría de Disponibilidad", y = "Frecuencia")
```

Las barras representan la cantidad de propiedades disponibles según diferentes rangos de días al año en que están disponibles para ser alquiladas.

-   **Categorías de Disponibilidad (Eje X)**: Se dividen en seis categorías distintas: "No disponible", "Hasta 30 días", "31 a 60 días", "61 a 90 días", "91 a 180 días", y "181 a 365 días".

-   **Frecuencia (Eje Y)**: El eje vertical indica la cantidad de listados, con una escala que va desde 0 hasta más de 8000.

Observaciones clave del gráfico:

-   **No disponible** y **181 a 365 días** son las categorías con la mayor frecuencia, indicando que una gran cantidad de propiedades no están disponibles para alquiler o están disponibles casi todo el año.

-   Las demás categorías presentan una menor frecuencia, con la categoría "31 a 60 días" mostrando la menor cantidad de propiedades. Esto sugiere que menos propiedades están disponibles por períodos intermedios de tiempo.

-   Las propiedades que se alquilan por "91 a 180 días" tienen una frecuencia considerablemente más alta que las de corto plazo pero menor que las de muy largo plazo, reflejando posiblemente una preferencia por alquileres de medio término.

```{r}


# Gráfico para Time_category
ggplot(airbnb_data, aes(x = Time_category)) +
  geom_bar(fill = "yellow") +
  labs(title = "Distribución de Time_category (Resta entre Scrapping date y Date.last.review)", x = "Time_category", y = "Frecuencia")

# Gráfico para Review_category
ggplot(airbnb_data, aes(x = Review_category)) +
  geom_bar(fill = "green") +
  labs(title = "Distribución de Review_category (Categorizacion de Number.of.reviews.per.month)", x = "Review_category", y = "Frecuencia")

# Gráfico para Review_Count_Category
ggplot(airbnb_data, aes(x = Review_Count_Category)) +
  geom_bar(fill = "blue") +
  labs(title = "Distribución de Review_Count_Category (Categorizacion de Number.of.reviews)", x = "Review_Count_Category", y = "Frecuencia")

```

##### Variables Numéricas

```{r}
# Cargar la librería necesaria
library(ggplot2)

# Boxplot para Room.Price
ggplot(airbnb_data, aes(y = Room.Price)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  labs(title = "Distribución del Precio de la Habitación",
       y = "Precio (€)",
       x = "") +
  theme_minimal()

# Boxplot para Minimum.nights
ggplot(airbnb_data, aes(y = Minimum.nights)) +
  geom_boxplot(fill = "lightgreen", color = "darkgreen") +
  labs(title = "Distribución del Número Mínimo de Noches Requeridas",
       y = "Número Mínimo de Noches",
       x = "") +
  theme_minimal()

# Boxplot para Rooms.rent.by.the.host
ggplot(airbnb_data, aes(y = Rooms.rent.by.the.host)) +
  geom_boxplot(fill = "lightyellow", color = "goldenrod") +
  labs(title = "Distribución del Número de Habitaciones alquiladas por el host",
       y = "Habitaciones alquiladas por el host",
       x = "") +
  theme_minimal()

```

```{r}

# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Room.Price)) +
  geom_density(fill = "blue", alpha = 0.5) +
  labs(title = "Distribución de Precios", x = "Precio", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Minimum.nights)) +
  geom_density(fill = "green", alpha = 0.5) +
  labs(title = "Distribución de Minimum.nights", x = "Minimum.nights", y = "Densidad")


# Crear un gráfico de densidad
ggplot(airbnb_data, aes(x = Rooms.rent.by.the.host)) +
  geom_density(fill = "yellow", alpha = 0.5) +
  labs(title = "Distribución de Rooms.rent.by.the.host", x = "Rooms.rent.by.the.host", y = "Densidad")

```

#### **Otros gráficos**

#### **Histograma del vecindario en términos de distritos**

```{r}

library(ggplot2)
library(dplyr)

# Calcular la frecuencia de cada distrito
distrito_frecuencia <- airbnb_data %>%
  count(Neighbourhood) %>%
  arrange(desc(n))  # Ordenar en orden descendente por frecuencia

# Obtener los top 10 distritos más frecuentes
top10_distritos <- distrito_frecuencia %>%
  top_n(10, n)

# Reorganizar el factor Neighbourhood en función de su frecuencia
airbnb_data$Neighbourhood <- factor(airbnb_data$Neighbourhood, levels = distrito_frecuencia$Neighbourhood)

# Filtrar solo las filas que corresponden a los 10 principales distritos
airbnb_data_top10 <- airbnb_data %>%
  filter(Neighbourhood %in% top10_distritos$Neighbourhood)

# Trazar el histograma
ggplot(airbnb_data_top10, aes(x = Neighbourhood)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Histograma Top10 del Vecindario en Términos de Distritos", subtitle="(Top 10, Orden Descendente)", 
       x = "Distrito", 
       y = "Frecuencia") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

El gráfico muestra un histograma del vecindario en términos de distritos, centrándose en los diez distritos más frecuentes en los datos de Airbnb. Los distritos están ordenados en orden descendente según su frecuencia. Cada barra representa la frecuencia de un distrito específico, lo que proporciona una visión general de la distribución de la popularidad de los distritos en el conjunto de datos.\
\
**Observaciones del Gráfico:**

-   **Embajadores** es el distrito con la mayor frecuencia de listados, seguido de **Universidad** y **Palacio**, indicando que estas áreas son probablemente las más demandadas o con más oferta de alojamientos en Airbnb.

-   A partir de **Sol** en adelante, la frecuencia de los listados comienza a disminuir progresivamente.

-   Los distritos como **Goya** y **Puerta del Angel** muestran las menores frecuencias dentro de este top 10, lo que podría sugerir una menor popularidad o una oferta más limitada de alojamientos en estas áreas comparado con distritos como Embajadores o Universidad.

#### **Presunciones basadas en el gráfico:**

1.  **Relación entre precio y popularidad de los distritos**: Podemos examinar si los distritos más populares, tienen precios más altos en promedio, sugiriendo que la demanda podría estar influyendo en el precio.

2.  **Impacto de las reseñas en la frecuencia de reserva**: Con datos sobre el número de reseñas y la frecuencia de estas (por mes), podemos analizar si las propiedades con más reseñas tienden a estar en distritos más populares, indicando posiblemente una mayor satisfacción o mayor rotación de huéspedes.

3.  **Efectos de la disponibilidad en la elección del distrito**: Con la categoría de disponibilidad, podríamos investigar si los distritos con propiedades más disponibles (o menos) son más o menos populares, lo que puede influir en la estrategia de precios y promoción.

\
**Distribución de precio vs número de reseñas**\

```{r}
ggplot(airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) +

geom_point(color = "blue") +

labs(title = "Distribución de Precio vs Número de Reseñas", x = "Precio de la Habitación (€)", y = "Número de Reseñas")


```

#### **Observaciones del Gráfico:**

-   La mayoría de las propiedades tienen un precio por debajo de los 1,000 euros y reciben menos de 200 reseñas.

-   Hay una gran concentración de puntos cerca del origen, lo que sugiere que muchas propiedades tienen precios bajos y un número moderado o bajo de reseñas.

-   Existen unas pocas propiedades con precios muy altos (más de 2,500 euros) y con variados niveles de reseñas, incluyendo algunas con muy pocas o ninguna reseña.

-   Propiedades con un gran número de reseñas (más de 200) generalmente tienen precios inferiores a 1,000 euros.

#### **Presunciones y Análisis Basados en los Datos del Dataset:**

1.  **Precio vs Popularidad**: Parece haber una relación inversa entre el precio y el número de reseñas, donde las propiedades más económicas tienden a tener más reseñas. Esto podría sugerir que las propiedades más asequibles son más populares o tienen una mayor rotación de huéspedes.

2.  **Propiedades de Alta Gama**: Las propiedades con precios muy altos tienden a tener menos reseñas, lo que podría indicar una menor ocupación o que estas propiedades son alquiladas menos frecuentemente. Esto puede deberse a que son opciones menos asequibles para la mayoría de los viajeros.

3.  **Segmentación del Mercado**: La distribución de precios y reseñas puede ayudar a identificar diferentes segmentos de mercado dentro del dataset de Airbnb, como alojamientos económicos, de rango medio y de lujo.

\
**Precio promedio vs tipo de habitación**\

```{r}
library(ggplot2)

ggplot(airbnb_data, aes(x = Room.type, y = Room.Price)) +
  geom_bar(stat = "summary", fun = "mean", fill = "lightgreen", color = "darkgreen") +
  geom_hline(yintercept = mean(airbnb_data$Room.Price), color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Precio Promedio vs Tipo de Habitación", x = "Tipo de Habitación", y = "Precio Promedio (€)")





```

\
El gráfico muestra el precio promedio de las habitaciones de Airbnb en relación con el tipo de habitación. Cada barra representa el precio promedio de un tipo específico de habitación, mientras que la línea roja punteada indica el precio promedio general de todas las habitaciones en el conjunto de datos. Esto proporciona una comparación visual entre los precios promedio de diferentes tipos de habitaciones, así como una referencia rápida del precio promedio general.

### **Observaciones del Gráfico:**

-   **Casa o Apartamento Completo**: Este tipo de alojamiento tiene el precio promedio más alto, considerablemente más alto que los otros tipos, lo que indica que alquilar una propiedad completa es generalmente más costoso.

-   **Habitación de Hotel**: Tiene un precio promedio significativamente más bajo que un apartamento o casa completa, pero más alto que una habitación privada o compartida.

-   **Habitación Privada**: Presenta un precio promedio más bajo que la habitación de hotel.

-   **Habitación Compartida**: Es la opción más económica, con el precio promedio más bajo entre los tipos de habitaciones mostrados.

### **Presunciones y Análisis Basados en el Gráfico:**

1.  **Preferencia y Precio**: Los precios reflejan posiblemente la preferencia de privacidad y espacio, con opciones más privadas y espaciosas como "Entire home/apt" que tienen un precio más alto.

2.  **Oferta y Demanda**: La diferencia en los precios podría reflejar la oferta y demanda de cada tipo de habitación, donde habitaciones completas y privadas son posiblemente más demandadas para largas estancias o grupos más grandes.

3.  **Presupuesto de Viajeros**: Los precios pueden también indicar el presupuesto típico de los viajeros que eligen diferentes tipos de habitaciones, con viajeros de presupuesto limitado optando más probablemente por habitaciones compartidas o privadas.

#### Tipo de propiedad y áreas (distritos) 

```{r}
# Crear un gráfico de barras apiladas 

ggplot(data = airbnb_data, aes(x = Neighbourhood, fill = `Room.type`)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Cantidad") + ggtitle("Distribución de tipos de propiedad por distritos en Madrid")
```

El gráfico muestra la distribución de los diferentes tipos de propiedades en cada distrito de Madrid. Cada barra representa un distrito y los segmentos de cada barra están coloreados para representar los diferentes tipos de propiedad. Los segmentos de cada barra se apilan unos sobre otros.

#### Distribución de precios vs distrito 

```{r}
ggplot(data = airbnb_data, aes(x = Neighbourhood, y = Room.Price)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(x = "Distrito", y = "Precio") + ggtitle("Distribución de precios por distrito en Madrid")
```

\
Este gráfico representa la distribución de los precios para cada distrito. Cada caja muestra la distribución de los precios en un distrito específico, donde la línea en el centro de la caja representa la mediana de los precios. Los puntos individuales fuera de los bigotes representan valores atípicos potenciales.

#### Tendencia mediana y puntuación de reseñas 

```{r}
ggplot(data = airbnb_data, aes(x = Room.Price, y = Number.of.reviews)) + geom_point() + geom_smooth(method = "lm", se = FALSE, color = "red") + labs(x = "Precio", y = "Puntuación  de reseñas") + ggtitle("Tendencia de la mediana de precios por puntuación de reseñas por distrito en Madrid")
```

\
Este gráfico muestra la relación entre el precio y el puntuación de las reseñas recibidas. Cada punto en el gráfico representa un listado individual, donde la posición horizontal del punto indica el precio y la posición vertical indica el número de reseñas.

El gráfico incluye una línea de tendencia (en rojo) ajustada mediante un modelo de regresión lineal. Esta línea de tendencia representa la tendencia general entre el precio y el número de reseñas: si la línea de tendencia tiene una pendiente positiva, indica una relación positiva entre el precio y el número de reseñas, mientras que una pendiente negativa indica una relación negativa.

#### Gráfico de Distribución en Madrid

Las columnas `Latitude` y `Longitude` están disponibles, podemos crear un mapa de puntos en Madrid:

```{r}
# Instalar y cargar los paquetes necesarios
if (!require("leaflet")) install.packages("leaflet")
library(leaflet)
if (!require("leaflet.extras")) install.packages("leaflet.extras")
library(leaflet.extras)


# Crear un mapa con Leaflet
madrid_map <- leaflet(data = airbnb_data) |>
  addTiles()  # Añadir el mapa base

# Añadir la capa de mapa de calor
madrid_map <- madrid_map |>
  addHeatmap(
    lng = ~Longitude, lat = ~Latitude, intensity = ~1,
    blur = 20, max = 0.05, radius = 15
  )

# Establecer la vista inicial del mapa y mostrarlo
madrid_map <- madrid_map |>
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map

```

```{r}
# Cargar el paquete dplyr para manipulación de datos
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)

# Definir una función para determinar el color basado en el precio
get_color <- function(price) {
  if (price < 50) {
    "#00FF00"  # Verde para precios bajos
  } else if (price < 100) {
    "#FFFF00"  # Amarillo para precios medios
  } else {
    "#FF0000"  # Rojo para precios altos
  }
}

# Añadir una nueva columna al dataset con los colores calculados
airbnb_data <- airbnb_data %>%
  mutate(Color = sapply(Room.Price, get_color))

# Crear el mapa
library(leaflet)

madrid_map <- leaflet(data = airbnb_data) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(
    ~Longitude, ~Latitude,
    radius = 5,
    color = ~Color,
    fillOpacity = 0.5,
    stroke = FALSE,  # No dibujar bordes alrededor de los círculos
    group = "Airbnb Locations"
  ) %>%
  setView(lng = -3.703, lat = 40.416, zoom = 11)

# Imprimir el mapa
madrid_map


```

#### Mapa de Calor de Correlación

Para el mapa de calor de correlación, seleccionamos las columnas numéricas relevantes.

```{r}

# Instalar paquetes si no están instalados
if (!require("dplyr")) install.packages("dplyr")
if (!require("corrplot")) install.packages("corrplot")

library(dplyr)
library(corrplot)

# Seleccionando columnas relevantes para la correlación
cor_data <- airbnb_data |>
  select(Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host) |>
  na.omit()  # Eliminando filas con valores NA para evitar errores

# Calculando la matriz de correlación
cor_matrix <- cor(cor_data)

# Generando el mapa de calor
corrplot(cor_matrix, method = "color", type = "upper", order = "hclust",
         tl.col = "black", tl.srt = 45, addrect = 2, 
         title = "Mapa de Calor de Correlación para AirBnB en Madrid",
         mar = c(0, 0, 2, 0))  # Ajusta el margen superior para dar más espacio al título


```

```{r}
library("ggplot2")
library("GGally")

airbnb_data2 <- select(airbnb_data, Room.Price, Minimum.nights, Number.of.reviews, Number.of.reviews.per.month, Rooms.rent.by.the.host)

ggpairs(airbnb_data2)
```

```{r}

if (!require(writexl)) {
    install.packages("writexl")
}
library(writexl)
# Exportar el dataframe
write_xlsx(airbnb_data, "dataset_airbnb_procesado.xlsx")

```
